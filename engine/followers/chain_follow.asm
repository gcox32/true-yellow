; Chain Follower System - Misty and Brock
; Misty follows Pikachu, Brock follows Misty

; =====================================
; UNIFIED SPAWN DISPATCHER
; =====================================
; Called from home bank, dispatches to appropriate follower spawn function

SpawnFollower_::
	ldh a, [hCurrentSpriteOffset]
	cp $f0 ; pikachu (slot 15)
	jp z, SpawnPikachu_
	cp $e0 ; brock (slot 14)
	jp z, SpawnBrock_
	jp SpawnMisty_ ; misty (slot 13)

; =====================================
; MISTY FOLLOWER LOGIC
; =====================================
; Note: wSpriteMistyStateData1, wSpriteMistyStateData2, and all their field labels
; (e.g., wSpriteMistyStateData1MovementStatus, wSpriteMistyStateData2MapY, etc.)
; are automatically generated by the spritestatedata1/spritestatedata2 macros in wram.asm

; =====================================
; MISTY SPAWN CONDITION CHECK
; =====================================

ShouldMistySpawn::
; Returns carry if Misty should spawn
; Conditions: EVENT_MISTY_FOLLOWING_PLAYER is set, Pikachu is visible, not biking/surfing
	; Check if Misty following flag is set
	ld a, [wMistyOverworldStateFlags]
	bit 5, a
	jr nz, .hide
	bit 7, a
	jr nz, .hide

	; Check event flag (use full 16-bit offset since event is at $9F0)
	ld hl, wEventFlags
	ld de, EVENT_MISTY_FOLLOWING_PLAYER / 8
	add hl, de
	ld a, [hl]
	bit EVENT_MISTY_FOLLOWING_PLAYER % 8, a
	jr z, .hide

	; Check if Pikachu is spawned (movement status != 0)
	; TEMPORARILY DISABLED for debugging - uncomment when working
	; ld a, [wSpritePikachuStateData1MovementStatus]
	; and a
	; jr z, .hide

	; Check if not biking/surfing
	ld a, [wWalkBikeSurfState]
	and a
	jr nz, .hide

	scf
	ret

.hide
	and a
	ret

; =====================================
; BROCK SPAWN CONDITION CHECK
; =====================================

ShouldBrockSpawn::
; Returns carry if Brock should spawn
; Conditions: Has Boulder AND Cascade badges, Misty is visible, not biking/surfing
	; Check if Brock following flag overrides
	ld a, [wBrockOverworldStateFlags]
	bit 5, a
	jr nz, .hide
	bit 7, a
	jr nz, .hide

	; Check if has both Boulder and Cascade badges
	ld a, [wObtainedBadges]
	and (1 << BIT_BOULDERBADGE) | (1 << BIT_CASCADEBADGE)
	cp (1 << BIT_BOULDERBADGE) | (1 << BIT_CASCADEBADGE)
	jr nz, .hide

	; Check if Misty is spawned (movement status != 0)
	ld a, [wSpriteMistyStateData1MovementStatus]
	and a
	jr z, .hide

	; Check if not biking/surfing
	ld a, [wWalkBikeSurfState]
	and a
	jr nz, .hide

	scf
	ret

.hide
	and a
	ret

; =====================================
; MISTY MAIN SPAWN FUNCTION
; =====================================

SpawnMisty_::
	call ShouldMistySpawn
	jr c, .shouldSpawn

	; Shouldn't spawn - hide the sprite
	ld a, $ff
	ld [wSpriteMistyStateData1ImageIndex], a  ; Set ImageIndex to $ff (offscreen)
	xor a
	ld [wSpriteMistyStateData1MovementStatus], a  ; Set MovementStatus to 0
	ret

.shouldSpawn
	; Check if Misty already spawned
	ld a, [wSpriteMistyStateData1MovementStatus]
	and a
	jr nz, .alreadySpawned

	; Initialize Misty's spawn position (behind Pikachu)
	call InitializeMistyPosition

.alreadySpawned
	; Update Misty's movement based on state
	ld a, [wSpriteMistyStateData1MovementStatus]
	and $7f
	cp 3
	jr z, .doWalk
	cp 5
	jr z, .doWalk

	; Status 0 or 1 - just update and check commands
	call UpdateMistyIdleState
	ret

.doWalk
	call UpdateMistyWalking
	ret

; =====================================
; BROCK MAIN SPAWN FUNCTION
; =====================================

SpawnBrock_::
	call ShouldBrockSpawn
	jr c, .shouldSpawn

	; Shouldn't spawn - hide the sprite
	ld a, $ff
	ld [wSpriteBrockStateData1ImageIndex], a  ; Set ImageIndex to $ff (offscreen)
	xor a
	ld [wSpriteBrockStateData1MovementStatus], a  ; Set MovementStatus to 0
	ret

.shouldSpawn
	; Check if Brock already spawned
	ld a, [wSpriteBrockStateData1MovementStatus]
	and a
	jr nz, .alreadySpawned

	; Initialize Brock's spawn position (behind Misty)
	call InitializeBrockPosition

.alreadySpawned
	; Update Brock's movement based on state
	ld a, [wSpriteBrockStateData1MovementStatus]
	and $7f
	cp 3
	jr z, .doWalk
	cp 5
	jr z, .doWalk

	; Status 0 or 1 - just update and check commands
	call UpdateBrockIdleState
	ret

.doWalk
	call UpdateBrockWalking
	ret

; =====================================
; MISTY POSITION INITIALIZATION
; =====================================

InitializeMistyPosition:
	; Place Misty one tile behind Pikachu
	; First ensure PictureID and ImageBaseOffset are set (required for sprite to be processed)
	ld a, SPRITE_BRUNETTE_GIRL
	ld [wSpriteMistyStateData1PictureID], a
	ld [wSpriteMistyStateData2PictureID], a
	
	; Set VRAM slot (ImageBaseOffset) - required for sprite to be processed
	ld a, $3  ; Misty is in VRAM slot 3 (after player=1, pikachu=2)
	ld [wSpriteMistyStateData2ImageBaseOffset], a
	
	; Get Pikachu's position
	ld a, [wSpritePikachuStateData2MapY]
	ld b, a
	ld a, [wSpritePikachuStateData2MapX]
	ld c, a

	; Get Pikachu's facing direction to determine offset
	ld a, [wSpritePikachuStateData1FacingDirection]
	and a ; SPRITE_FACING_DOWN
	jr z, .placeAbove
	cp SPRITE_FACING_UP
	jr z, .placeBelow
	cp SPRITE_FACING_LEFT
	jr z, .placeRight
	; SPRITE_FACING_RIGHT - place left
	dec c
	jr .setPosition

.placeAbove
	dec b
	jr .setPosition

.placeBelow
	inc b
	jr .setPosition

.placeRight
	inc c

.setPosition
	; Set Misty's position
	ld a, b
	ld [wSpriteMistyStateData2MapY], a
	ld a, c
	ld [wSpriteMistyStateData2MapX], a

	; Set movement status to 1 (ready)
	ld a, 1
	ld [wSpriteMistyStateData1MovementStatus], a

	; Copy Pikachu's facing direction
	ld a, [wSpritePikachuStateData1FacingDirection]
	ld [wSpriteMistyStateData1FacingDirection], a

	; Clear command buffer
	call ClearMistyFollowCommandBuffer

	; Initialize screen position
	push bc
	ld bc, wSpriteMistyStateData1
	farcall InitializeSpriteScreenPosition
	pop bc
	
	; Set initial image index (same calculation as UpdatePikachuWalkingSprite)
	; ImageIndex = (ImageBaseOffset - 1) << 4 | FacingDirection | AnimFrameCounter
	ld a, [wSpriteMistyStateData2ImageBaseOffset]
	dec a
	swap a  ; shift left by 4 bits
	and $f0  ; mask to upper 4 bits
	ld b, a
	ld a, [wSpriteMistyStateData1FacingDirection]
	or b
	ld [wSpriteMistyStateData1ImageIndex], a
	
	ret

; =====================================
; BROCK POSITION INITIALIZATION
; =====================================

InitializeBrockPosition:
	; Place Brock one tile behind Misty
	; First ensure PictureID and ImageBaseOffset are set (required for sprite to be processed)
	ld a, SPRITE_HIKER
	ld [wSpriteBrockStateData1PictureID], a
	ld [wSpriteBrockStateData2PictureID], a
	
	; Set VRAM slot (ImageBaseOffset) - required for sprite to be processed
	; Note: Brock would need a VRAM slot, but since we don't have one reserved yet,
	; we'll use a slot that's available. For now, we'll need to add Brock to the sprite set.
	; TODO: Add Brock's sprite to sprite sets and assign proper VRAM slot
	ld a, $4  ; Temporary VRAM slot (will need proper assignment)
	ld [wSpriteBrockStateData2ImageBaseOffset], a
	
	; Get Misty's position
	ld a, [wSpriteMistyStateData2MapY]
	ld b, a
	ld a, [wSpriteMistyStateData2MapX]
	ld c, a

	; Get Misty's facing direction to determine offset
	ld a, [wSpriteMistyStateData1FacingDirection]
	and a ; SPRITE_FACING_DOWN
	jr z, .placeAbove
	cp SPRITE_FACING_UP
	jr z, .placeBelow
	cp SPRITE_FACING_LEFT
	jr z, .placeRight
	; SPRITE_FACING_RIGHT - place left
	dec c
	jr .setPosition

.placeAbove
	dec b
	jr .setPosition

.placeBelow
	inc b
	jr .setPosition

.placeRight
	inc c

.setPosition
	; Set Brock's position
	ld a, b
	ld [wSpriteBrockStateData2MapY], a
	ld a, c
	ld [wSpriteBrockStateData2MapX], a

	; Set movement status to 1 (ready)
	ld a, 1
	ld [wSpriteBrockStateData1MovementStatus], a

	; Copy Misty's facing direction
	ld a, [wSpriteMistyStateData1FacingDirection]
	ld [wSpriteBrockStateData1FacingDirection], a

	; Clear command buffer
	call ClearBrockFollowCommandBuffer

	; Initialize screen position
	push bc
	ld bc, wSpriteBrockStateData1
	farcall InitializeSpriteScreenPosition
	pop bc
	
	; Set initial image index (same calculation as UpdatePikachuWalkingSprite)
	; ImageIndex = (ImageBaseOffset - 1) << 4 | FacingDirection | AnimFrameCounter
	ld a, [wSpriteBrockStateData2ImageBaseOffset]
	dec a
	swap a  ; shift left by 4 bits
	and $f0  ; mask to upper 4 bits
	ld b, a
	ld a, [wSpriteBrockStateData1FacingDirection]
	or b
	ld [wSpriteBrockStateData1ImageIndex], a
	
	ret

; =====================================
; MISTY IDLE STATE UPDATE
; =====================================

UpdateMistyIdleState:
; Check buffer first (synchronized with player/Pikachu movement)
; Fall back to real-time computation if buffer empty
	; Check if there's a command in the buffer
	ld a, [wMistyFollowCommandBufferSize]
	cp $ff
	jr z, .computeRealTime  ; Buffer empty, compute now

	; Get command from buffer
	ld hl, wMistyFollowCommandBuffer
	ld a, [hl]
	ld b, a  ; Save command

	; Clear buffer
	ld hl, wMistyFollowCommandBufferSize
	ld [hl], $ff

	; Use the buffered command
	ld a, b
	jr .processCommand

.computeRealTime
	; No buffered command - compute direction now (fallback)
	call ComputeMistyFollowCommand
	jr c, .noMovementNeeded  ; carry = already at target

.processCommand

	; Process movement command (1-4 = normal, 5-8 = fast)
	ld b, a  ; save command
	dec a    ; 0-7
	cp 4
	jr c, .normalSpeed

	; Fast movement (command 5-8)
	sub 4    ; convert 5-8 to 0-3 (direction)
	add a    ; * 2
	add a    ; * 4 (facing direction offset)
	ld [wSpriteMistyStateData1FacingDirection], a

	; Set movement status to 5 (fast walking)
	ld a, 5
	ld [wSpriteMistyStateData1MovementStatus], a

	; Set walk animation counter (4 frames = faster)
	ld a, 4
	ld [wSpriteMistyStateData2WalkAnimationCounter], a

	; Set step vectors based on direction
	call SetMistyStepVector
	ret

.normalSpeed
	; Normal movement (command 1-4)
	; a is already 0-3
	add a    ; * 2
	add a    ; * 4 (facing direction offset)
	ld [wSpriteMistyStateData1FacingDirection], a

	; Set movement status to 3 (walking)
	ld a, 3
	ld [wSpriteMistyStateData1MovementStatus], a

	; Set walk animation counter (8 frames = normal)
	ld a, 8
	ld [wSpriteMistyStateData2WalkAnimationCounter], a

	; Set step vectors based on direction
	call SetMistyStepVector
	ret

.noMovementNeeded
	; Stay in idle, update screen position and facing direction
	push bc
	ld bc, wSpriteMistyStateData1
	farcall InitializeSpriteScreenPosition
	pop bc

	; Update facing direction based on position relative to Pikachu
	call ComputeMistyFacingDirection

	; Update sprite image index
	call UpdateMistyWalkingSprite
	ret

; =====================================
; BROCK IDLE STATE UPDATE
; =====================================

UpdateBrockIdleState:
; Check buffer first (synchronized with player/Pikachu movement)
; Fall back to real-time computation if buffer empty
	; Check if there's a command in the buffer
	ld a, [wBrockFollowCommandBufferSize]
	cp $ff
	jr z, .computeRealTime  ; Buffer empty, compute now

	; Get command from buffer
	ld hl, wBrockFollowCommandBuffer
	ld a, [hl]
	ld b, a  ; Save command

	; Clear buffer
	ld hl, wBrockFollowCommandBufferSize
	ld [hl], $ff

	; Use the buffered command
	ld a, b
	jr .processCommand

.computeRealTime
	; No buffered command - compute direction now (fallback)
	call ComputeBrockFollowCommand
	jr c, .noMovementNeeded  ; carry = already at target

.processCommand

	; Process movement command (1-4 = normal, 5-8 = fast)
	ld b, a  ; save command
	dec a    ; 0-7
	cp 4
	jr c, .normalSpeed

	; Fast movement (command 5-8)
	sub 4    ; convert 5-8 to 0-3 (direction)
	add a    ; * 2
	add a    ; * 4 (facing direction offset)
	ld [wSpriteBrockStateData1FacingDirection], a

	; Set movement status to 5 (fast walking)
	ld a, 5
	ld [wSpriteBrockStateData1MovementStatus], a

	; Set walk animation counter (4 frames = faster)
	ld a, 4
	ld [wSpriteBrockStateData2WalkAnimationCounter], a

	; Set step vectors based on direction
	call SetBrockStepVector
	ret

.normalSpeed
	; Normal movement (command 1-4)
	; a is already 0-3
	add a    ; * 2
	add a    ; * 4 (facing direction offset)
	ld [wSpriteBrockStateData1FacingDirection], a

	; Set movement status to 3 (walking)
	ld a, 3
	ld [wSpriteBrockStateData1MovementStatus], a

	; Set walk animation counter (8 frames = normal)
	ld a, 8
	ld [wSpriteBrockStateData2WalkAnimationCounter], a

	; Set step vectors based on direction
	call SetBrockStepVector
	ret

.noMovementNeeded
	; Stay in idle, update screen position
	push bc
	ld bc, wSpriteBrockStateData1
	farcall InitializeSpriteScreenPosition
	pop bc
	ret

; =====================================
; MISTY WALKING UPDATE
; =====================================

UpdateMistyWalking:
	; Decrement walk counter
	ld hl, wSpriteMistyStateData2WalkAnimationCounter
	dec [hl]
	jr nz, .continueWalk

	; Walk complete - update map position and return to idle
	call UpdateMistyMapPosition

	; Clear step vectors
	xor a
	ld [wSpriteMistyStateData1 + SPRITESTATEDATA1_YSTEPVECTOR], a
	ld [wSpriteMistyStateData1 + SPRITESTATEDATA1_XSTEPVECTOR], a

	; Reset animation frame to standing (0)
	xor a
	ld [wSpriteMistyStateData1AnimFrameCounter], a

	; Recompute facing direction based on position relative to Pikachu
	call ComputeMistyFacingDirection

	; Return to idle state
	ld a, 1
	ld [wSpriteMistyStateData1MovementStatus], a

	; Update sprite one more time with standing frame
	call UpdateMistyWalkingSprite
	ret

.continueWalk
	; Update animation frame counter for walking animation
	; Use a simple two-phase animation: frames 8-5 = anim 1, frames 4-1 = anim 2
	; This gives a smooth walking motion that changes once per step
	ld a, [wSpriteMistyStateData2WalkAnimationCounter]
	cp 5           ; counter >= 5?
	ld a, 1        ; first half: walking frame 1
	jr nc, .setFrame
	ld a, 2        ; second half: walking frame 2
.setFrame
	ld [wSpriteMistyStateData1AnimFrameCounter], a

	; Check if fast walking (status 5) or normal (status 3)
	ld a, [wSpriteMistyStateData1MovementStatus]
	and $7f
	cp 5
	jr z, .fastWalk

	; Normal walk - 2 pixels per frame
	call UpdateMistyScreenPosition
	jr .updateSprite

.fastWalk
	; Fast walk - 4 pixels per frame (call twice)
	call UpdateMistyScreenPosition
	call UpdateMistyScreenPosition

.updateSprite
	; Update sprite image index during walk
	call UpdateMistyWalkingSprite
	ret

; =====================================
; BROCK WALKING UPDATE
; =====================================

UpdateBrockWalking:
	; Decrement walk counter
	ld hl, wSpriteBrockStateData2WalkAnimationCounter
	dec [hl]
	jr nz, .continueWalk

	; Walk complete - update map position and return to idle
	call UpdateBrockMapPosition

	; Clear step vectors
	xor a
	ld [wSpriteBrockStateData1 + SPRITESTATEDATA1_YSTEPVECTOR], a
	ld [wSpriteBrockStateData1 + SPRITESTATEDATA1_XSTEPVECTOR], a

	; Reset animation frame to standing (0)
	xor a
	ld [wSpriteBrockStateData1AnimFrameCounter], a

	; Return to idle state
	ld a, 1
	ld [wSpriteBrockStateData1MovementStatus], a

	; Update sprite with standing frame
	call UpdateBrockWalkingSprite
	ret

.continueWalk
	; Update animation frame counter for walking animation
	; Use a simple two-phase animation: frames 8-5 = anim 1, frames 4-1 = anim 2
	; This gives a smooth walking motion that changes once per step
	ld a, [wSpriteBrockStateData2WalkAnimationCounter]
	cp 5           ; counter >= 5?
	ld a, 1        ; first half: walking frame 1
	jr nc, .setBrockFrame
	ld a, 2        ; second half: walking frame 2
.setBrockFrame
	ld [wSpriteBrockStateData1AnimFrameCounter], a

	; Check if fast walking (status 5) or normal (status 3)
	ld a, [wSpriteBrockStateData1MovementStatus]
	and $7f
	cp 5
	jr z, .fastWalk

	; Normal walk - 2 pixels per frame
	call UpdateBrockScreenPosition
	jr .updateSprite

.fastWalk
	; Fast walk - 4 pixels per frame (call twice)
	call UpdateBrockScreenPosition
	call UpdateBrockScreenPosition

.updateSprite
	; Update sprite image index during walk
	call UpdateBrockWalkingSprite
	ret

; =====================================
; MISTY STEP VECTOR SETUP
; =====================================

SetMistyStepVector:
	ld a, [wSpriteMistyStateData1FacingDirection]
	and a ; SPRITE_FACING_DOWN (0)
	jr z, .down
	cp SPRITE_FACING_UP
	jr z, .up
	cp SPRITE_FACING_LEFT
	jr z, .left
	; RIGHT
	ld a, 1
	ld [wSpriteMistyStateData1 + SPRITESTATEDATA1_XSTEPVECTOR], a
	xor a
	ld [wSpriteMistyStateData1 + SPRITESTATEDATA1_YSTEPVECTOR], a
	ret

.down
	ld a, 1
	ld [wSpriteMistyStateData1 + SPRITESTATEDATA1_YSTEPVECTOR], a
	xor a
	ld [wSpriteMistyStateData1 + SPRITESTATEDATA1_XSTEPVECTOR], a
	ret

.up
	ld a, -1
	ld [wSpriteMistyStateData1 + SPRITESTATEDATA1_YSTEPVECTOR], a
	xor a
	ld [wSpriteMistyStateData1 + SPRITESTATEDATA1_XSTEPVECTOR], a
	ret

.left
	ld a, -1
	ld [wSpriteMistyStateData1 + SPRITESTATEDATA1_XSTEPVECTOR], a
	xor a
	ld [wSpriteMistyStateData1 + SPRITESTATEDATA1_YSTEPVECTOR], a
	ret

; =====================================
; BROCK STEP VECTOR SETUP
; =====================================

SetBrockStepVector:
	ld a, [wSpriteBrockStateData1FacingDirection]
	and a ; SPRITE_FACING_DOWN (0)
	jr z, .down
	cp SPRITE_FACING_UP
	jr z, .up
	cp SPRITE_FACING_LEFT
	jr z, .left
	; RIGHT
	ld a, 1
	ld [wSpriteBrockStateData1 + SPRITESTATEDATA1_XSTEPVECTOR], a
	xor a
	ld [wSpriteBrockStateData1 + SPRITESTATEDATA1_YSTEPVECTOR], a
	ret

.down
	ld a, 1
	ld [wSpriteBrockStateData1 + SPRITESTATEDATA1_YSTEPVECTOR], a
	xor a
	ld [wSpriteBrockStateData1 + SPRITESTATEDATA1_XSTEPVECTOR], a
	ret

.up
	ld a, -1
	ld [wSpriteBrockStateData1 + SPRITESTATEDATA1_YSTEPVECTOR], a
	xor a
	ld [wSpriteBrockStateData1 + SPRITESTATEDATA1_XSTEPVECTOR], a
	ret

.left
	ld a, -1
	ld [wSpriteBrockStateData1 + SPRITESTATEDATA1_XSTEPVECTOR], a
	xor a
	ld [wSpriteBrockStateData1 + SPRITESTATEDATA1_YSTEPVECTOR], a
	ret

; =====================================
; MISTY MAP POSITION UPDATE
; =====================================

UpdateMistyMapPosition:
	; Update map Y
	ld a, [wSpriteMistyStateData1 + SPRITESTATEDATA1_YSTEPVECTOR]
	ld b, a
	ld a, [wSpriteMistyStateData2MapY]
	add b
	ld [wSpriteMistyStateData2MapY], a

	; Update map X
	ld a, [wSpriteMistyStateData1 + SPRITESTATEDATA1_XSTEPVECTOR]
	ld b, a
	ld a, [wSpriteMistyStateData2MapX]
	add b
	ld [wSpriteMistyStateData2MapX], a
	ret

; =====================================
; BROCK MAP POSITION UPDATE
; =====================================

UpdateBrockMapPosition:
	; Update map Y
	ld a, [wSpriteBrockStateData1 + SPRITESTATEDATA1_YSTEPVECTOR]
	ld b, a
	ld a, [wSpriteBrockStateData2MapY]
	add b
	ld [wSpriteBrockStateData2MapY], a

	; Update map X
	ld a, [wSpriteBrockStateData1 + SPRITESTATEDATA1_XSTEPVECTOR]
	ld b, a
	ld a, [wSpriteBrockStateData2MapX]
	add b
	ld [wSpriteBrockStateData2MapX], a
	ret

; =====================================
; MISTY SCREEN POSITION UPDATE
; =====================================

UpdateMistyScreenPosition:
	; Update Y pixel position (2 pixels per frame)
	ld a, [wSpriteMistyStateData1 + SPRITESTATEDATA1_YSTEPVECTOR]
	add a ; double for 2 pixels per frame
	ld b, a
	ld a, [wSpriteMistyStateData1 + SPRITESTATEDATA1_YPIXELS]
	add b
	ld [wSpriteMistyStateData1 + SPRITESTATEDATA1_YPIXELS], a

	; Update X pixel position (2 pixels per frame)
	ld a, [wSpriteMistyStateData1 + SPRITESTATEDATA1_XSTEPVECTOR]
	add a ; double for 2 pixels per frame
	ld b, a
	ld a, [wSpriteMistyStateData1 + SPRITESTATEDATA1_XPIXELS]
	add b
	ld [wSpriteMistyStateData1 + SPRITESTATEDATA1_XPIXELS], a
	ret

; =====================================
; BROCK SCREEN POSITION UPDATE
; =====================================

UpdateBrockScreenPosition:
	; Update Y pixel position
	ld a, [wSpriteBrockStateData1 + SPRITESTATEDATA1_YSTEPVECTOR]
	add a ; double for 2 pixels per frame
	ld b, a
	ld a, [wSpriteBrockStateData1 + SPRITESTATEDATA1_YPIXELS]
	add b
	ld [wSpriteBrockStateData1 + SPRITESTATEDATA1_YPIXELS], a

	; Update X pixel position
	ld a, [wSpriteBrockStateData1 + SPRITESTATEDATA1_XSTEPVECTOR]
	add a ; double for 2 pixels per frame
	ld b, a
	ld a, [wSpriteBrockStateData1 + SPRITESTATEDATA1_XPIXELS]
	add b
	ld [wSpriteBrockStateData1 + SPRITESTATEDATA1_XPIXELS], a
	ret

; =====================================
; MISTY COMMAND BUFFER MANAGEMENT
; =====================================

ClearMistyFollowCommandBuffer:
; Clear command buffer - matches Pikachu's approach
	push bc
	ld hl, wMistyFollowCommandBufferSize
	ld [hl], $ff
	inc hl
	ld bc, 8  ; 8-byte buffer
	xor a
	call FillMemory
	pop bc
	ret

AppendMistyFollowCommand::
; Called when player moves - compute and store command for Misty
; This runs at the same time as Pikachu's command, keeping them in sync
	call ShouldMistySpawn
	ret nc

	; Compute direction from Misty to target tile (behind Pikachu)
	call ComputeMistyFollowCommand
	ret c  ; Already at target, no command needed

	; Store command in buffer
	ld hl, wMistyFollowCommandBuffer
	ld [hl], a
	ld hl, wMistyFollowCommandBufferSize
	ld [hl], 0  ; Size 0 = 1 command
	ret

GetMistyFollowCommand:
; Get and consume command from buffer (LIFO - from end)
; Matches Pikachu's Func_fcc92 approach
	ld hl, wMistyFollowCommandBufferSize
	ld a, [hl]
	cp $ff
	jr z, .empty
	and a
	jr z, .empty
	dec [hl]
	ld e, a
	ld d, 0
	ld hl, wMistyFollowCommandBuffer
	add hl, de
	inc e
	ld a, $ff
.shiftLoop
	ld d, [hl]
	ld [hld], a
	ld a, d
	dec e
	jr nz, .shiftLoop
	and a  ; clear carry
	ret

.empty
	scf
	ret

; =====================================
; BROCK COMMAND BUFFER MANAGEMENT
; =====================================

ClearBrockFollowCommandBuffer:
; Clear command buffer - matches Pikachu's approach
	push bc
	ld hl, wBrockFollowCommandBufferSize
	ld [hl], $ff
	inc hl
	ld bc, 8  ; 8-byte buffer
	xor a
	call FillMemory
	pop bc
	ret

AppendBrockFollowCommand::
; Called when player moves - compute and store command for Brock
; This runs at the same time as Pikachu's command, keeping them in sync
	call ShouldBrockSpawn
	ret nc

	; Compute direction from Brock to target tile (behind Misty)
	call ComputeBrockFollowCommand
	ret c  ; Already at target, no command needed

	; Store command in buffer
	ld hl, wBrockFollowCommandBuffer
	ld [hl], a
	ld hl, wBrockFollowCommandBufferSize
	ld [hl], 0  ; Size 0 = 1 command
	ret

GetBrockFollowCommand:
; Get and consume command from buffer (LIFO - from end)
; Matches Pikachu's Func_fcc92 approach
	ld hl, wBrockFollowCommandBufferSize
	ld a, [hl]
	cp $ff
	jr z, .empty
	and a
	jr z, .empty
	dec [hl]
	ld e, a
	ld d, 0
	ld hl, wBrockFollowCommandBuffer
	add hl, de
	inc e
	ld a, $ff
.shiftLoop
	ld d, [hl]
	ld [hld], a
	ld a, d
	dec e
	jr nz, .shiftLoop
	and a  ; clear carry
	ret

.empty
	scf
	ret

; =====================================
; MISTY FOLLOW COMMAND COMPUTATION
; =====================================

ComputeMistyFollowCommand:
; Compute direction from Misty to the tile BEHIND Pikachu
; Target tile = Pikachu's position offset by opposite of facing direction
; Returns: a = command (1-4 normal speed, 5-8 fast speed), carry set if no movement needed
	; First compute target tile (behind Pikachu)
	call GetMistyTargetTile
	; Returns: d = target Y, e = target X

	; Compute distance from Misty to target
	ld a, [wSpriteMistyStateData2MapY]
	ld b, a
	ld a, d
	sub b  ; a = target.Y - Misty.Y
	ld b, a  ; b = Y distance to target

	ld a, [wSpriteMistyStateData2MapX]
	ld c, a
	ld a, e
	sub c  ; a = target.X - Misty.X
	ld c, a  ; c = X distance to target

	; Check if already at target
	ld a, b
	or c
	jr z, .onTarget  ; both distances 0 = at target

	; Need to move toward target
	; Prioritize the axis with greater distance
	ld a, b
	call AbsoluteValue
	ld d, a  ; d = |Y distance|
	ld a, c
	call AbsoluteValue
	ld e, a  ; e = |X distance|

	; Compare distances - move on axis with greater distance
	ld a, d
	cp e
	jr c, .moveX  ; |Y| < |X|, prioritize X
	jr z, .moveY  ; equal, default to Y (or could check X)
	; |Y| > |X|, prioritize Y

.moveY
	ld a, b  ; Y distance
	and a
	jr z, .moveX  ; if Y is 0, must move X
	bit 7, a
	jr nz, .moveUp  ; negative = target above Misty

	; Target below Misty - move down
	ld a, d  ; |Y distance|
	cp 2
	jr c, .downNormal
	ld a, 5  ; fast down
	and a
	ret
.downNormal
	ld a, 1  ; normal down
	and a
	ret

.moveUp
	; Target above Misty - move up
	ld a, d  ; |Y distance|
	cp 2
	jr c, .upNormal
	ld a, 6  ; fast up
	and a
	ret
.upNormal
	ld a, 2  ; normal up
	and a
	ret

.moveX
	ld a, c  ; X distance
	and a
	jr z, .onTarget  ; if X is also 0, we're at target
	bit 7, a
	jr nz, .moveLeft  ; negative = target left of Misty

	; Target right of Misty - move right
	ld a, e  ; |X distance|
	cp 2
	jr c, .rightNormal
	ld a, 8  ; fast right
	and a
	ret
.rightNormal
	ld a, 4  ; normal right
	and a
	ret

.moveLeft
	; Target left of Misty - move left
	ld a, e  ; |X distance|
	cp 2
	jr c, .leftNormal
	ld a, 7  ; fast left
	and a
	ret
.leftNormal
	ld a, 3  ; normal left
	and a
	ret

.onTarget
	; At target position, no movement needed
	scf
	ret

GetMistyTargetTile:
; Target the tile Pikachu WILL vacate (his current position)
; But offset by 1 in the direction Pikachu is moving (based on facing)
; This way Misty stays 1 tile behind even as Pikachu moves
; Returns: d = target Y, e = target X
	ld a, [wSpritePikachuStateData2MapY]
	ld d, a
	ld a, [wSpritePikachuStateData2MapX]
	ld e, a

	; Check Pikachu's facing to determine where "behind" is
	ld a, [wSpritePikachuStateData1FacingDirection]
	and a  ; SPRITE_FACING_DOWN (0)
	jr z, .facingDown
	cp SPRITE_FACING_UP
	jr z, .facingUp
	cp SPRITE_FACING_LEFT
	jr z, .facingLeft
	; SPRITE_FACING_RIGHT - behind is to the left (X-1)
	dec e
	ret
.facingDown
	; Behind is above (Y-1)
	dec d
	ret
.facingUp
	; Behind is below (Y+1)
	inc d
	ret
.facingLeft
	; Behind is to the right (X+1)
	inc e
	ret

AbsoluteValue:
; Returns absolute value of a
	bit 7, a
	ret z  ; already positive
	cpl
	inc a
	ret

; =====================================
; MISTY FACING DIRECTION COMPUTATION
; =====================================

ComputeMistyFacingDirection:
; Compute facing direction based on Misty's position relative to Pikachu
; Does NOT consume from command buffer - just computes facing based on position
	; Compare Y coordinates
	ld a, [wSpritePikachuStateData2MapY]
	ld b, a
	ld a, [wSpriteMistyStateData2MapY]
	cp b
	jr z, .checkX
	jr c, .mistyAbovePikachu

	; Misty is below Pikachu - face up
	ld a, SPRITE_FACING_UP
	jr .setFacing

.mistyAbovePikachu
	; Misty is above Pikachu - face down
	ld a, SPRITE_FACING_DOWN
	jr .setFacing

.checkX
	; Y coords equal - check X
	ld a, [wSpritePikachuStateData2MapX]
	ld b, a
	ld a, [wSpriteMistyStateData2MapX]
	cp b
	jr z, .copyPikachuFacing
	jr c, .mistyLeftOfPikachu

	; Misty is right of Pikachu - face left
	ld a, SPRITE_FACING_LEFT
	jr .setFacing

.mistyLeftOfPikachu
	; Misty is left of Pikachu - face right
	ld a, SPRITE_FACING_RIGHT
	jr .setFacing

.copyPikachuFacing
	; On same tile - copy Pikachu's facing direction
	ld a, [wSpritePikachuStateData1FacingDirection]

.setFacing
	ld [wSpriteMistyStateData1FacingDirection], a
	ret

; =====================================
; MISTY WALKING SPRITE UPDATE
; =====================================

UpdateMistyWalkingSprite:
; Update sprite image index based on facing direction and animation frame
; Similar to UpdatePikachuWalkingSprite
	ld a, [wSpriteMistyStateData2ImageBaseOffset]
	dec a
	swap a  ; shift left by 4 bits
	and $f0  ; mask to upper 4 bits
	ld b, a
	ld a, [wSpriteMistyStateData1FacingDirection]
	or b
	ld b, a

	; Add animation frame counter
	ld a, [wSpriteMistyStateData1AnimFrameCounter]
	or b
	ld [wSpriteMistyStateData1ImageIndex], a
	ret

; =====================================
; BROCK WALKING SPRITE UPDATE
; =====================================

UpdateBrockWalkingSprite:
; Update sprite image index based on facing direction and animation frame
	ld a, [wSpriteBrockStateData2ImageBaseOffset]
	dec a
	swap a  ; shift left by 4 bits
	and $f0  ; mask to upper 4 bits
	ld b, a
	ld a, [wSpriteBrockStateData1FacingDirection]
	or b
	ld b, a

	; Add animation frame counter
	ld a, [wSpriteBrockStateData1AnimFrameCounter]
	or b
	ld [wSpriteBrockStateData1ImageIndex], a
	ret

; =====================================
; BROCK FOLLOW COMMAND COMPUTATION
; =====================================

ComputeBrockFollowCommand:
; Compute direction from Brock to the tile BEHIND Misty
; Target tile = Misty's position offset by opposite of facing direction
; Returns: a = command (1-4 normal speed, 5-8 fast speed), carry set if no movement needed
	; First compute target tile (behind Misty)
	call GetBrockTargetTile
	; Returns: d = target Y, e = target X

	; Compute distance from Brock to target
	ld a, [wSpriteBrockStateData2MapY]
	ld b, a
	ld a, d
	sub b  ; a = target.Y - Brock.Y
	ld b, a  ; b = Y distance to target

	ld a, [wSpriteBrockStateData2MapX]
	ld c, a
	ld a, e
	sub c  ; a = target.X - Brock.X
	ld c, a  ; c = X distance to target

	; Check if already at target
	ld a, b
	or c
	jr z, .onTarget  ; both distances 0 = at target

	; Need to move toward target
	; Prioritize the axis with greater distance
	ld a, b
	call AbsoluteValue
	ld d, a  ; d = |Y distance|
	ld a, c
	call AbsoluteValue
	ld e, a  ; e = |X distance|

	; Compare distances - move on axis with greater distance
	ld a, d
	cp e
	jr c, .moveX  ; |Y| < |X|, prioritize X
	jr z, .moveY  ; equal, default to Y
	; |Y| > |X|, prioritize Y

.moveY
	ld a, b  ; Y distance
	and a
	jr z, .moveX  ; if Y is 0, must move X
	bit 7, a
	jr nz, .moveUp  ; negative = target above Brock

	; Target below Brock - move down
	ld a, d  ; |Y distance|
	cp 2
	jr c, .downNormal
	ld a, 5  ; fast down
	and a
	ret
.downNormal
	ld a, 1  ; normal down
	and a
	ret

.moveUp
	; Target above Brock - move up
	ld a, d  ; |Y distance|
	cp 2
	jr c, .upNormal
	ld a, 6  ; fast up
	and a
	ret
.upNormal
	ld a, 2  ; normal up
	and a
	ret

.moveX
	ld a, c  ; X distance
	and a
	jr z, .onTarget  ; if X is also 0, we're at target
	bit 7, a
	jr nz, .moveLeft  ; negative = target left of Brock

	; Target right of Brock - move right
	ld a, e  ; |X distance|
	cp 2
	jr c, .rightNormal
	ld a, 8  ; fast right
	and a
	ret
.rightNormal
	ld a, 4  ; normal right
	and a
	ret

.moveLeft
	; Target left of Brock - move left
	ld a, e  ; |X distance|
	cp 2
	jr c, .leftNormal
	ld a, 7  ; fast left
	and a
	ret
.leftNormal
	ld a, 3  ; normal left
	and a
	ret

.onTarget
	; At target position, no movement needed
	scf
	ret

GetBrockTargetTile:
; Target the tile BEHIND Misty based on her facing direction
; This keeps Brock 1 tile behind Misty as she moves
; Returns: d = target Y, e = target X
	ld a, [wSpriteMistyStateData2MapY]
	ld d, a
	ld a, [wSpriteMistyStateData2MapX]
	ld e, a

	; Check Misty's facing to determine where "behind" is
	ld a, [wSpriteMistyStateData1FacingDirection]
	and a  ; SPRITE_FACING_DOWN (0)
	jr z, .facingDown
	cp SPRITE_FACING_UP
	jr z, .facingUp
	cp SPRITE_FACING_LEFT
	jr z, .facingLeft
	; SPRITE_FACING_RIGHT - behind is to the left (X-1)
	dec e
	ret
.facingDown
	; Behind is above (Y-1)
	dec d
	ret
.facingUp
	; Behind is below (Y+1)
	inc d
	ret
.facingLeft
	; Behind is to the right (X+1)
	inc e
	ret

; =====================================
; MISTY INITIALIZATION (called from script)
; =====================================

InitializeMistyFollower::
; Called when Misty first starts following - clears state and initializes position
	; Clear state flags (ensures spawn conditions can pass)
	xor a
	ld [wMistyOverworldStateFlags], a

	; Clear StateData1 (16 bytes) - note: StateData1 and StateData2 are NOT contiguous
	ld hl, wSpriteMistyStateData1
	ld bc, $10
	xor a
	call FillMemory

	; Clear StateData2 (16 bytes) - in separate memory page
	ld hl, wSpriteMistyStateData2
	ld bc, $10
	xor a
	call FillMemory

	; Set sprite picture ID
	ld a, SPRITE_BRUNETTE_GIRL
	ld [wSpriteMistyStateData1PictureID], a
	ld [wSpriteMistyStateData2PictureID], a

	; Set VRAM slot (ImageBaseOffset) - required for sprite to be processed
	ld a, $3  ; Misty is in VRAM slot 3 (after player=1, pikachu=2)
	ld [wSpriteMistyStateData2ImageBaseOffset], a

	; Set image index to $ff (will be updated on first spawn)
	ld a, $ff
	ld [wSpriteMistyStateData1ImageIndex], a

	; Clear movement status (will be set by InitializeMistyPosition)
	xor a
	ld [wSpriteMistyStateData1MovementStatus], a

	; Clear command buffer
	call ClearMistyFollowCommandBuffer

	; Initialize position (behind Pikachu)
	call InitializeMistyPosition

	; Set initial image index (same calculation as UpdatePikachuWalkingSprite)
	; ImageIndex = (ImageBaseOffset - 1) << 4 | FacingDirection | AnimFrameCounter
	ld a, [wSpriteMistyStateData2ImageBaseOffset]
	dec a
	swap a  ; shift left by 4 bits
	and $f0  ; mask to upper 4 bits
	ld b, a
	ld a, [wSpriteMistyStateData1FacingDirection]
	or b
	ld [wSpriteMistyStateData1ImageIndex], a

	; Clear anim frame counter
	xor a
	ld [wSpriteMistyStateData1AnimFrameCounter], a

	ret

; =====================================
; HELPER: Initialize Follower Screen Position
; (This reuses existing InitializeSpriteScreenPosition)
; =====================================

; Note: The farcall to InitializeSpriteScreenPosition requires bc to point
; to the sprite's StateData1 base address
