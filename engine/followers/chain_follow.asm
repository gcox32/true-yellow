; Chain Follower System - Misty and Brock
; Uses Position Trail approach: stores where player WAS for the last N steps
; Pikachu targets trail[0], Misty targets trail[1], Brock targets trail[2]

; =====================================
; UNIFIED SPAWN DISPATCHER
; =====================================
; Called from home bank, dispatches to appropriate follower spawn function

SpawnFollower_::
	ldh a, [hCurrentSpriteOffset]
	cp $f0 ; pikachu (slot 15)
	jp z, SpawnPikachu_
	cp $e0 ; brock (slot 14)
	jp z, SpawnBrock_
	jp SpawnMisty_ ; misty (slot 13)

; =====================================
; POSITION TRAIL MANAGEMENT
; =====================================
; The position trail stores where the player WAS for the last 4 steps.
; When player moves, we shift the trail and record their previous position.
; Each follower targets a specific offset in the trail.

RecordPlayerPositionToTrail::
; Called when player completes a step - shifts trail and records previous position
; Should be called BEFORE player position is updated, or with the old position
; Input: b = old Y position (map coords + 4), c = old X position (map coords + 4)
	; Shift trail entries: [3] <- [2] <- [1] <- [0]
	ld a, [wPositionTrailY + 2]
	ld [wPositionTrailY + 3], a
	ld a, [wPositionTrailX + 2]
	ld [wPositionTrailX + 3], a

	ld a, [wPositionTrailY + 1]
	ld [wPositionTrailY + 2], a
	ld a, [wPositionTrailX + 1]
	ld [wPositionTrailX + 2], a

	ld a, [wPositionTrailY + 0]
	ld [wPositionTrailY + 1], a
	ld a, [wPositionTrailX + 0]
	ld [wPositionTrailX + 1], a

	; Store new position at trail[0]
	ld a, b
	ld [wPositionTrailY + 0], a
	ld a, c
	ld [wPositionTrailX + 0], a
	ret

InitializePositionTrail::
; Initialize trail with positions behind the player
; Creates a line of positions extending behind player based on facing direction
	; Get player's current position
	ld a, [wYCoord]
	add 4
	ld b, a
	ld a, [wXCoord]
	add 4
	ld c, a

	; Get player's facing direction to determine trail direction
	ld a, [wSpritePlayerStateData1FacingDirection]
	ld d, a  ; save facing direction

	; Fill trail[0] through trail[3] with positions behind player
	; Each position is one step further behind

	; trail[0] = 1 step behind player (Pikachu's target)
	call .computeBehindPosition
	ld a, b
	ld [wPositionTrailY + 0], a
	ld a, c
	ld [wPositionTrailX + 0], a

	; trail[1] = 2 steps behind player (Misty's target)
	call .computeBehindPosition
	ld a, b
	ld [wPositionTrailY + 1], a
	ld a, c
	ld [wPositionTrailX + 1], a

	; trail[2] = 3 steps behind player (Brock's target)
	call .computeBehindPosition
	ld a, b
	ld [wPositionTrailY + 2], a
	ld a, c
	ld [wPositionTrailX + 2], a

	; trail[3] = 4 steps behind player (spare)
	call .computeBehindPosition
	ld a, b
	ld [wPositionTrailY + 3], a
	ld a, c
	ld [wPositionTrailX + 3], a
	ret

.computeBehindPosition:
; Compute position one step behind current (b,c) based on facing direction d
; Modifies b,c to be the position behind
	ld a, d
	and a ; SPRITE_FACING_DOWN
	jr z, .behindDown
	cp SPRITE_FACING_UP
	jr z, .behindUp
	cp SPRITE_FACING_LEFT
	jr z, .behindLeft
	; SPRITE_FACING_RIGHT - behind is to the left
	dec c
	ret
.behindDown
	; Facing down - behind is above (Y-1)
	dec b
	ret
.behindUp
	; Facing up - behind is below (Y+1)
	inc b
	ret
.behindLeft
	; Facing left - behind is to the right (X+1)
	inc c
	ret

; =====================================
; MISTY FOLLOWER LOGIC
; =====================================
; Note: wSpriteMistyStateData1, wSpriteMistyStateData2, and all their field labels
; (e.g., wSpriteMistyStateData1MovementStatus, wSpriteMistyStateData2MapY, etc.)
; are automatically generated by the spritestatedata1/spritestatedata2 macros in wram.asm

; =====================================
; MISTY SPAWN CONDITION CHECK
; =====================================

ShouldMistySpawn::
; Returns carry if Misty should spawn
; Conditions: EVENT_MISTY_FOLLOWING_PLAYER is set, Pikachu is visible, not biking/surfing
	; Check if Misty following flag is set
	ld a, [wMistyOverworldStateFlags]
	bit 5, a
	jr nz, .hide
	bit 7, a
	jr nz, .hide

	; Special case: If in Cerulean Gym and haven't beaten Misty yet, hide follower
	; (Misty should be at her gym leader spot instead)
	ld a, [wCurMap]
	cp CERULEAN_GYM
	jr nz, .notCeruleanGym
	; We're in Cerulean Gym - check if EVENT_BEAT_MISTY is set
	ld hl, wEventFlags
	ld de, EVENT_BEAT_MISTY / 8
	add hl, de
	ld a, [hl]
	bit EVENT_BEAT_MISTY % 8, a
	jr z, .hide ; If not beaten, hide follower (she's at gym leader spot)
.notCeruleanGym

	; Check event flag (use full 16-bit offset since event is at $9F0)
	ld hl, wEventFlags
	ld de, EVENT_MISTY_FOLLOWING_PLAYER / 8
	add hl, de
	ld a, [hl]
	bit EVENT_MISTY_FOLLOWING_PLAYER % 8, a
	jr z, .hide

	; Check if Pikachu is spawned (movement status != 0)
	; TEMPORARILY DISABLED for debugging - uncomment when working
	; ld a, [wSpritePikachuStateData1MovementStatus]
	; and a
	; jr z, .hide

	; Check if not biking/surfing
	ld a, [wWalkBikeSurfState]
	and a
	jr nz, .hide

	scf
	ret

.hide
	and a
	ret

; =====================================
; BROCK SPAWN CONDITION CHECK
; =====================================

ShouldBrockSpawn::
; Returns carry if Brock should spawn
; Conditions: Has Boulder badge, Pikachu is visible, not biking/surfing
; If Misty is also following, Brock will follow behind her in the chain
	; Check if Brock following flag overrides
	ld a, [wBrockOverworldStateFlags]
	bit 5, a
	jr nz, .hide
	bit 7, a
	jr nz, .hide

	; Check if has Boulder badge (required to have defeated Brock)
	ld a, [wObtainedBadges]
	bit BIT_BOULDERBADGE, a
	jr z, .hide

	; Check if Pikachu is spawned (movement status != 0)
	; Brock can follow Pikachu directly, or Misty if she's also following
	ld a, [wSpritePikachuStateData1MovementStatus]
	and a
	jr z, .hide

	; Check if not biking/surfing
	ld a, [wWalkBikeSurfState]
	and a
	jr nz, .hide

	scf
	ret

.hide
	and a
	ret

; =====================================
; MISTY MAIN SPAWN FUNCTION
; =====================================

SpawnMisty_::
	call ShouldMistySpawn
	jr c, .shouldSpawn

	; Shouldn't spawn - hide the sprite
	ld a, $ff
	ld [wSpriteMistyStateData1ImageIndex], a  ; Set ImageIndex to $ff (offscreen)
	xor a
	ld [wSpriteMistyStateData1MovementStatus], a  ; Set MovementStatus to 0
	ret

.shouldSpawn
	; Check if Misty already spawned
	ld a, [wSpriteMistyStateData1MovementStatus]
	and a
	jr nz, .alreadySpawned

	; Fresh spawn (e.g. new map) - reinitialize position trail first
	call InitializePositionTrail
	; Initialize Misty's spawn position (behind Pikachu)
	call InitializeMistyPosition

.alreadySpawned
	; Update Misty's movement based on state
	ld a, [wSpriteMistyStateData1MovementStatus]
	and $7f
	cp 3
	jr z, .doWalk
	cp 5
	jr z, .doWalk

	; Status 0 or 1 - just update and check commands
	call UpdateMistyIdleState
	ret

.doWalk
	call UpdateMistyWalking
	ret

; =====================================
; BROCK MAIN SPAWN FUNCTION
; =====================================

SpawnBrock_::
	call ShouldBrockSpawn
	jr c, .shouldSpawn

	; Shouldn't spawn - hide the sprite
	ld a, $ff
	ld [wSpriteBrockStateData1ImageIndex], a  ; Set ImageIndex to $ff (offscreen)
	xor a
	ld [wSpriteBrockStateData1MovementStatus], a  ; Set MovementStatus to 0
	ret

.shouldSpawn
	; Check if Brock already spawned
	ld a, [wSpriteBrockStateData1MovementStatus]
	and a
	jr nz, .alreadySpawned

	; Fresh spawn (e.g. new map) - reinitialize position trail first
	call InitializePositionTrail
	; Initialize Brock's spawn position (behind Misty)
	call InitializeBrockPosition

.alreadySpawned
	; Update Brock's movement based on state
	ld a, [wSpriteBrockStateData1MovementStatus]
	and $7f
	cp 3
	jr z, .doWalk
	cp 5
	jr z, .doWalk

	; Status 0 or 1 - just update and check commands
	call UpdateBrockIdleState
	ret

.doWalk
	call UpdateBrockWalking
	ret

; =====================================
; MISTY POSITION INITIALIZATION
; =====================================

InitializeMistyPosition:
	; Place Misty at trail[1] position (2 steps behind player)
	; First ensure PictureID and ImageBaseOffset are set (required for sprite to be processed)
	ld a, SPRITE_MISTY
	ld [wSpriteMistyStateData1PictureID], a
	ld [wSpriteMistyStateData2PictureID], a

	; Set VRAM slot (ImageBaseOffset) - required for sprite to be processed
	ld a, $3  ; Misty is in VRAM slot 3 (after player=1, pikachu=2)
	ld [wSpriteMistyStateData2ImageBaseOffset], a

	; Get position from trail[1] (Misty's target)
	ld a, [wPositionTrailY + 1]
	ld [wSpriteMistyStateData2MapY], a
	ld a, [wPositionTrailX + 1]
	ld [wSpriteMistyStateData2MapX], a

	; Set movement status to 1 (ready)
	ld a, 1
	ld [wSpriteMistyStateData1MovementStatus], a

	; Copy player's facing direction
	ld a, [wSpritePlayerStateData1FacingDirection]
	ld [wSpriteMistyStateData1FacingDirection], a

	; Initialize screen position
	push bc
	ld bc, wSpriteMistyStateData1
	farcall InitializeSpriteScreenPosition
	pop bc

	; Set initial image index
	; ImageIndex = (ImageBaseOffset - 1) << 4 | FacingDirection | AnimFrameCounter
	ld a, [wSpriteMistyStateData2ImageBaseOffset]
	dec a
	swap a  ; shift left by 4 bits
	and $f0  ; mask to upper 4 bits
	ld b, a
	ld a, [wSpriteMistyStateData1FacingDirection]
	or b
	ld [wSpriteMistyStateData1ImageIndex], a

	ret

; =====================================
; BROCK POSITION INITIALIZATION
; =====================================

InitializeBrockPosition:
	; Place Brock at trail[2] position (3 steps behind player)
	; First ensure PictureID and ImageBaseOffset are set (required for sprite to be processed)
	ld a, SPRITE_BROCK
	ld [wSpriteBrockStateData1PictureID], a
	ld [wSpriteBrockStateData2PictureID], a

	; Set VRAM slot (ImageBaseOffset) - required for sprite to be processed
	ld a, $4  ; Brock is in VRAM slot 4 (after player=1, pikachu=2, misty=3)
	ld [wSpriteBrockStateData2ImageBaseOffset], a

	; Get position from trail[2] (Brock's target)
	ld a, [wPositionTrailY + 2]
	ld [wSpriteBrockStateData2MapY], a
	ld a, [wPositionTrailX + 2]
	ld [wSpriteBrockStateData2MapX], a

	; Set movement status to 1 (ready)
	ld a, 1
	ld [wSpriteBrockStateData1MovementStatus], a

	; Copy player's facing direction
	ld a, [wSpritePlayerStateData1FacingDirection]
	ld [wSpriteBrockStateData1FacingDirection], a

	; Initialize screen position
	push bc
	ld bc, wSpriteBrockStateData1
	farcall InitializeSpriteScreenPosition
	pop bc

	; Set initial image index
	; ImageIndex = (ImageBaseOffset - 1) << 4 | FacingDirection | AnimFrameCounter
	ld a, [wSpriteBrockStateData2ImageBaseOffset]
	dec a
	swap a  ; shift left by 4 bits
	and $f0  ; mask to upper 4 bits
	ld b, a
	ld a, [wSpriteBrockStateData1FacingDirection]
	or b
	ld [wSpriteBrockStateData1ImageIndex], a

	ret

; =====================================
; MISTY IDLE STATE UPDATE
; =====================================

UpdateMistyIdleState:
; Check if Misty needs to move toward her trail target (trail[1])
; Compare current position to target, move if different
	; Get target position from trail[1]
	ld a, [wPositionTrailY + 1]
	ld b, a  ; b = target Y
	ld a, [wPositionTrailX + 1]
	ld c, a  ; c = target X

	; Get Misty's current position
	ld a, [wSpriteMistyStateData2MapY]
	ld d, a  ; d = current Y
	ld a, [wSpriteMistyStateData2MapX]
	ld e, a  ; e = current X

	; Compare Y coordinates
	ld a, d
	cp b
	jr z, .checkX
	jr c, .moveDown   ; current Y < target Y, need to move down
	jr .moveUp        ; current Y > target Y, need to move up

.checkX
	; Y coordinates match, check X
	ld a, e
	cp c
	jr z, .atTarget   ; both match, at target
	jr c, .moveRight  ; current X < target X, need to move right
	jr .moveLeft      ; current X > target X, need to move left

.moveDown
	ld a, SPRITE_FACING_DOWN
	jr .startWalk
.moveUp
	ld a, SPRITE_FACING_UP
	jr .startWalk
.moveLeft
	ld a, SPRITE_FACING_LEFT
	jr .startWalk
.moveRight
	ld a, SPRITE_FACING_RIGHT

.startWalk
	; Set facing direction
	ld [wSpriteMistyStateData1FacingDirection], a

	; Calculate Manhattan distance to decide speed
	; d=current Y, e=current X, b=target Y, c=target X (still in registers)
	push bc
	; |target.Y - current.Y|
	ld a, b
	sub d
	jr nc, .yPosMisty
	cpl
	inc a
.yPosMisty
	ld h, a  ; h = |Y distance|
	; |target.X - current.X|
	ld a, c
	sub e
	jr nc, .xPosMisty
	cpl
	inc a
.xPosMisty
	add h  ; a = Manhattan distance
	pop bc

	; If distance >= 2, use fast walking (status 5, 4 frames)
	cp 2
	jr c, .normalWalkMisty

	; Fast walking
	ld a, 5
	ld [wSpriteMistyStateData1MovementStatus], a
	ld a, 4
	ld [wSpriteMistyStateData2WalkAnimationCounter], a
	jr .doStepMisty

.normalWalkMisty
	; Normal walking (status 3, 8 frames)
	ld a, 3
	ld [wSpriteMistyStateData1MovementStatus], a
	ld a, 8
	ld [wSpriteMistyStateData2WalkAnimationCounter], a

.doStepMisty
	; Set step vectors based on direction
	call SetMistyStepVector

	; Update screen position immediately on first frame of walking
	; This prevents the 1-frame delay that accumulates
	; Check if fast walking (status 5) or normal (status 3)
	ld a, [wSpriteMistyStateData1MovementStatus]
	and $7f
	cp 5
	jr z, .fastWalkFirstFrame
	; Normal walk - 2 pixels
	call UpdateMistyScreenPosition
	jr .updateSpriteFirstFrame
.fastWalkFirstFrame
	; Fast walk - 4 pixels (call twice)
	call UpdateMistyScreenPosition
	call UpdateMistyScreenPosition
.updateSpriteFirstFrame
	; Update sprite
	call UpdateMistyWalkingSprite
	ret

.atTarget
	; Already at target position, stay idle
	; Update screen position in case of scrolling
	push bc
	ld bc, wSpriteMistyStateData1
	farcall InitializeSpriteScreenPosition
	pop bc

	; Update sprite image
	call UpdateMistyWalkingSprite
	ret

; =====================================
; BROCK IDLE STATE UPDATE
; =====================================

UpdateBrockIdleState:
; Check if Brock needs to move toward his trail target (trail[2])
; Compare current position to target, move if different
	; Get target position from trail[2]
	ld a, [wPositionTrailY + 2]
	ld b, a  ; b = target Y
	ld a, [wPositionTrailX + 2]
	ld c, a  ; c = target X

	; Get Brock's current position
	ld a, [wSpriteBrockStateData2MapY]
	ld d, a  ; d = current Y
	ld a, [wSpriteBrockStateData2MapX]
	ld e, a  ; e = current X

	; Compare Y coordinates
	ld a, d
	cp b
	jr z, .checkX
	jr c, .moveDown   ; current Y < target Y, need to move down
	jr .moveUp        ; current Y > target Y, need to move up

.checkX
	; Y coordinates match, check X
	ld a, e
	cp c
	jr z, .atTarget   ; both match, at target
	jr c, .moveRight  ; current X < target X, need to move right
	jr .moveLeft      ; current X > target X, need to move left

.moveDown
	ld a, SPRITE_FACING_DOWN
	jr .startWalk
.moveUp
	ld a, SPRITE_FACING_UP
	jr .startWalk
.moveLeft
	ld a, SPRITE_FACING_LEFT
	jr .startWalk
.moveRight
	ld a, SPRITE_FACING_RIGHT

.startWalk
	; Set facing direction
	ld [wSpriteBrockStateData1FacingDirection], a

	; Calculate Manhattan distance to decide speed
	; d=current Y, e=current X, b=target Y, c=target X (still in registers)
	push bc
	; |target.Y - current.Y|
	ld a, b
	sub d
	jr nc, .yPosBrock
	cpl
	inc a
.yPosBrock
	ld h, a  ; h = |Y distance|
	; |target.X - current.X|
	ld a, c
	sub e
	jr nc, .xPosBrock
	cpl
	inc a
.xPosBrock
	add h  ; a = Manhattan distance
	pop bc

	; If distance >= 2, use fast walking (status 5, 4 frames)
	cp 2
	jr c, .normalWalkBrock

	; Fast walking
	ld a, 5
	ld [wSpriteBrockStateData1MovementStatus], a
	ld a, 4
	ld [wSpriteBrockStateData2WalkAnimationCounter], a
	jr .doStepBrock

.normalWalkBrock
	; Normal walking (status 3, 8 frames)
	ld a, 3
	ld [wSpriteBrockStateData1MovementStatus], a
	ld a, 8
	ld [wSpriteBrockStateData2WalkAnimationCounter], a

.doStepBrock
	; Set step vectors based on direction
	call SetBrockStepVector

	; Update screen position immediately on first frame of walking
	; This prevents the 1-frame delay that accumulates
	; Check if fast walking (status 5) or normal (status 3)
	ld a, [wSpriteBrockStateData1MovementStatus]
	and $7f
	cp 5
	jr z, .fastWalkFirstFrameBrock
	; Normal walk - 2 pixels
	call UpdateBrockScreenPosition
	jr .updateSpriteFirstFrameBrock
.fastWalkFirstFrameBrock
	; Fast walk - 4 pixels (call twice)
	call UpdateBrockScreenPosition
	call UpdateBrockScreenPosition
.updateSpriteFirstFrameBrock
	; Update sprite
	call UpdateBrockWalkingSprite
	ret

.atTarget
	; Already at target position, stay idle
	; Update screen position in case of scrolling
	push bc
	ld bc, wSpriteBrockStateData1
	farcall InitializeSpriteScreenPosition
	pop bc

	; Update sprite image
	call UpdateBrockWalkingSprite
	ret

; =====================================
; MISTY WALKING UPDATE
; =====================================

UpdateMistyWalking:
	; Decrement walk counter
	ld hl, wSpriteMistyStateData2WalkAnimationCounter
	dec [hl]
	jr nz, .continueWalk

	; Walk complete - update map position and return to idle
	call UpdateMistyMapPosition

	; Clear step vectors
	xor a
	ld [wSpriteMistyStateData1 + SPRITESTATEDATA1_YSTEPVECTOR], a
	ld [wSpriteMistyStateData1 + SPRITESTATEDATA1_XSTEPVECTOR], a

	; Reset animation frame to standing (0)
	xor a
	ld [wSpriteMistyStateData1AnimFrameCounter], a

	; Return to idle state
	ld a, 1
	ld [wSpriteMistyStateData1MovementStatus], a

	; Immediately check for next movement (no 1-frame delay)
	; This prevents the "step, pause, step, pause" pattern
	jp UpdateMistyIdleState

.continueWalk
	; Update animation frame counter for walking animation
	; Use a simple two-phase animation: frames 8-5 = anim 1, frames 4-1 = anim 2
	; This gives a smooth walking motion that changes once per step
	ld a, [wSpriteMistyStateData2WalkAnimationCounter]
	cp 5           ; counter >= 5?
	ld a, 1        ; first half: walking frame 1
	jr nc, .setFrame
	ld a, 2        ; second half: walking frame 2
.setFrame
	ld [wSpriteMistyStateData1AnimFrameCounter], a

	; Check if fast walking (status 5) or normal (status 3)
	ld a, [wSpriteMistyStateData1MovementStatus]
	and $7f
	cp 5
	jr z, .fastWalk

	; Normal walk - 2 pixels per frame
	call UpdateMistyScreenPosition
	jr .updateSprite

.fastWalk
	; Fast walk - 4 pixels per frame (call twice)
	call UpdateMistyScreenPosition
	call UpdateMistyScreenPosition

.updateSprite
	; Update sprite image index during walk
	call UpdateMistyWalkingSprite
	ret

; =====================================
; BROCK WALKING UPDATE
; =====================================

UpdateBrockWalking:
	; Decrement walk counter
	ld hl, wSpriteBrockStateData2WalkAnimationCounter
	dec [hl]
	jr nz, .continueWalk

	; Walk complete - update map position and return to idle
	call UpdateBrockMapPosition

	; Clear step vectors
	xor a
	ld [wSpriteBrockStateData1 + SPRITESTATEDATA1_YSTEPVECTOR], a
	ld [wSpriteBrockStateData1 + SPRITESTATEDATA1_XSTEPVECTOR], a

	; Reset animation frame to standing (0)
	xor a
	ld [wSpriteBrockStateData1AnimFrameCounter], a

	; Return to idle state
	ld a, 1
	ld [wSpriteBrockStateData1MovementStatus], a

	; Immediately check for next movement (no 1-frame delay)
	; This prevents the "step, pause, step, pause" pattern
	jp UpdateBrockIdleState

.continueWalk
	; Update animation frame counter for walking animation
	; Use a simple two-phase animation: frames 8-5 = anim 1, frames 4-1 = anim 2
	; This gives a smooth walking motion that changes once per step
	ld a, [wSpriteBrockStateData2WalkAnimationCounter]
	cp 5           ; counter >= 5?
	ld a, 1        ; first half: walking frame 1
	jr nc, .setBrockFrame
	ld a, 2        ; second half: walking frame 2
.setBrockFrame
	ld [wSpriteBrockStateData1AnimFrameCounter], a

	; Check if fast walking (status 5) or normal (status 3)
	ld a, [wSpriteBrockStateData1MovementStatus]
	and $7f
	cp 5
	jr z, .fastWalk

	; Normal walk - 2 pixels per frame
	call UpdateBrockScreenPosition
	jr .updateSprite

.fastWalk
	; Fast walk - 4 pixels per frame (call twice)
	call UpdateBrockScreenPosition
	call UpdateBrockScreenPosition

.updateSprite
	; Update sprite image index during walk
	call UpdateBrockWalkingSprite
	ret

; =====================================
; MISTY STEP VECTOR SETUP
; =====================================

SetMistyStepVector:
	ld a, [wSpriteMistyStateData1FacingDirection]
	and a ; SPRITE_FACING_DOWN (0)
	jr z, .down
	cp SPRITE_FACING_UP
	jr z, .up
	cp SPRITE_FACING_LEFT
	jr z, .left
	; RIGHT
	ld a, 1
	ld [wSpriteMistyStateData1 + SPRITESTATEDATA1_XSTEPVECTOR], a
	xor a
	ld [wSpriteMistyStateData1 + SPRITESTATEDATA1_YSTEPVECTOR], a
	ret

.down
	ld a, 1
	ld [wSpriteMistyStateData1 + SPRITESTATEDATA1_YSTEPVECTOR], a
	xor a
	ld [wSpriteMistyStateData1 + SPRITESTATEDATA1_XSTEPVECTOR], a
	ret

.up
	ld a, -1
	ld [wSpriteMistyStateData1 + SPRITESTATEDATA1_YSTEPVECTOR], a
	xor a
	ld [wSpriteMistyStateData1 + SPRITESTATEDATA1_XSTEPVECTOR], a
	ret

.left
	ld a, -1
	ld [wSpriteMistyStateData1 + SPRITESTATEDATA1_XSTEPVECTOR], a
	xor a
	ld [wSpriteMistyStateData1 + SPRITESTATEDATA1_YSTEPVECTOR], a
	ret

; =====================================
; BROCK STEP VECTOR SETUP
; =====================================

SetBrockStepVector:
	ld a, [wSpriteBrockStateData1FacingDirection]
	and a ; SPRITE_FACING_DOWN (0)
	jr z, .down
	cp SPRITE_FACING_UP
	jr z, .up
	cp SPRITE_FACING_LEFT
	jr z, .left
	; RIGHT
	ld a, 1
	ld [wSpriteBrockStateData1 + SPRITESTATEDATA1_XSTEPVECTOR], a
	xor a
	ld [wSpriteBrockStateData1 + SPRITESTATEDATA1_YSTEPVECTOR], a
	ret

.down
	ld a, 1
	ld [wSpriteBrockStateData1 + SPRITESTATEDATA1_YSTEPVECTOR], a
	xor a
	ld [wSpriteBrockStateData1 + SPRITESTATEDATA1_XSTEPVECTOR], a
	ret

.up
	ld a, -1
	ld [wSpriteBrockStateData1 + SPRITESTATEDATA1_YSTEPVECTOR], a
	xor a
	ld [wSpriteBrockStateData1 + SPRITESTATEDATA1_XSTEPVECTOR], a
	ret

.left
	ld a, -1
	ld [wSpriteBrockStateData1 + SPRITESTATEDATA1_XSTEPVECTOR], a
	xor a
	ld [wSpriteBrockStateData1 + SPRITESTATEDATA1_YSTEPVECTOR], a
	ret

; =====================================
; MISTY MAP POSITION UPDATE
; =====================================

UpdateMistyMapPosition:
	; Update map Y
	ld a, [wSpriteMistyStateData1 + SPRITESTATEDATA1_YSTEPVECTOR]
	ld b, a
	ld a, [wSpriteMistyStateData2MapY]
	add b
	ld [wSpriteMistyStateData2MapY], a

	; Update map X
	ld a, [wSpriteMistyStateData1 + SPRITESTATEDATA1_XSTEPVECTOR]
	ld b, a
	ld a, [wSpriteMistyStateData2MapX]
	add b
	ld [wSpriteMistyStateData2MapX], a
	ret

; =====================================
; BROCK MAP POSITION UPDATE
; =====================================

UpdateBrockMapPosition:
	; Update map Y
	ld a, [wSpriteBrockStateData1 + SPRITESTATEDATA1_YSTEPVECTOR]
	ld b, a
	ld a, [wSpriteBrockStateData2MapY]
	add b
	ld [wSpriteBrockStateData2MapY], a

	; Update map X
	ld a, [wSpriteBrockStateData1 + SPRITESTATEDATA1_XSTEPVECTOR]
	ld b, a
	ld a, [wSpriteBrockStateData2MapX]
	add b
	ld [wSpriteBrockStateData2MapX], a
	ret

; =====================================
; MISTY SCREEN POSITION UPDATE
; =====================================

UpdateMistyScreenPosition:
	; Update Y pixel position (2 pixels per frame)
	ld a, [wSpriteMistyStateData1 + SPRITESTATEDATA1_YSTEPVECTOR]
	add a ; double for 2 pixels per frame
	ld b, a
	ld a, [wSpriteMistyStateData1 + SPRITESTATEDATA1_YPIXELS]
	add b
	ld [wSpriteMistyStateData1 + SPRITESTATEDATA1_YPIXELS], a

	; Update X pixel position (2 pixels per frame)
	ld a, [wSpriteMistyStateData1 + SPRITESTATEDATA1_XSTEPVECTOR]
	add a ; double for 2 pixels per frame
	ld b, a
	ld a, [wSpriteMistyStateData1 + SPRITESTATEDATA1_XPIXELS]
	add b
	ld [wSpriteMistyStateData1 + SPRITESTATEDATA1_XPIXELS], a
	ret

; =====================================
; BROCK SCREEN POSITION UPDATE
; =====================================

UpdateBrockScreenPosition:
	; Update Y pixel position
	ld a, [wSpriteBrockStateData1 + SPRITESTATEDATA1_YSTEPVECTOR]
	add a ; double for 2 pixels per frame
	ld b, a
	ld a, [wSpriteBrockStateData1 + SPRITESTATEDATA1_YPIXELS]
	add b
	ld [wSpriteBrockStateData1 + SPRITESTATEDATA1_YPIXELS], a

	; Update X pixel position
	ld a, [wSpriteBrockStateData1 + SPRITESTATEDATA1_XSTEPVECTOR]
	add a ; double for 2 pixels per frame
	ld b, a
	ld a, [wSpriteBrockStateData1 + SPRITESTATEDATA1_XPIXELS]
	add b
	ld [wSpriteBrockStateData1 + SPRITESTATEDATA1_XPIXELS], a
	ret

; =====================================
; MISTY FOLLOW COMMAND COMPUTATION (OBSOLETE)
; =====================================
; NOTE: This section is obsolete - we now use the position trail approach.
; Followers read their target position from wPositionTrailY/X and move toward it.

; =====================================
; MISTY FACING DIRECTION COMPUTATION
; =====================================

ComputeMistyFacingDirection:
; Compute facing direction based on Misty's position relative to Pikachu
; Does NOT consume from command buffer - just computes facing based on position
	; Compare Y coordinates
	ld a, [wSpritePikachuStateData2MapY]
	ld b, a
	ld a, [wSpriteMistyStateData2MapY]
	cp b
	jr z, .checkX
	jr c, .mistyAbovePikachu

	; Misty is below Pikachu - face up
	ld a, SPRITE_FACING_UP
	jr .setFacing

.mistyAbovePikachu
	; Misty is above Pikachu - face down
	ld a, SPRITE_FACING_DOWN
	jr .setFacing

.checkX
	; Y coords equal - check X
	ld a, [wSpritePikachuStateData2MapX]
	ld b, a
	ld a, [wSpriteMistyStateData2MapX]
	cp b
	jr z, .copyPikachuFacing
	jr c, .mistyLeftOfPikachu

	; Misty is right of Pikachu - face left
	ld a, SPRITE_FACING_LEFT
	jr .setFacing

.mistyLeftOfPikachu
	; Misty is left of Pikachu - face right
	ld a, SPRITE_FACING_RIGHT
	jr .setFacing

.copyPikachuFacing
	; On same tile - copy Pikachu's facing direction
	ld a, [wSpritePikachuStateData1FacingDirection]

.setFacing
	ld [wSpriteMistyStateData1FacingDirection], a
	ret

; =====================================
; MISTY WALKING SPRITE UPDATE
; =====================================

UpdateMistyWalkingSprite:
; Update sprite image index based on facing direction and animation frame
; Similar to UpdatePikachuWalkingSprite
	ld a, [wSpriteMistyStateData2ImageBaseOffset]
	dec a
	swap a  ; shift left by 4 bits
	and $f0  ; mask to upper 4 bits
	ld b, a
	ld a, [wSpriteMistyStateData1FacingDirection]
	or b
	ld b, a

	; Add animation frame counter
	ld a, [wSpriteMistyStateData1AnimFrameCounter]
	or b
	ld [wSpriteMistyStateData1ImageIndex], a
	ret

; =====================================
; BROCK WALKING SPRITE UPDATE
; =====================================

UpdateBrockWalkingSprite:
; Update sprite image index based on facing direction and animation frame
	ld a, [wSpriteBrockStateData2ImageBaseOffset]
	dec a
	swap a  ; shift left by 4 bits
	and $f0  ; mask to upper 4 bits
	ld b, a
	ld a, [wSpriteBrockStateData1FacingDirection]
	or b
	ld b, a

	; Add animation frame counter
	ld a, [wSpriteBrockStateData1AnimFrameCounter]
	or b
	ld [wSpriteBrockStateData1ImageIndex], a
	ret

; =====================================
; MISTY INITIALIZATION (called from script)
; =====================================

InitializeMistyFollower::
; Called when Misty first starts following - clears state and initializes position
	; Initialize position trail first (sets up positions for all followers)
	call InitializePositionTrail

	; Clear state flags (ensures spawn conditions can pass)
	xor a
	ld [wMistyOverworldStateFlags], a

	; Clear StateData1 (16 bytes) - note: StateData1 and StateData2 are NOT contiguous
	ld hl, wSpriteMistyStateData1
	ld bc, $10
	xor a
	call FillMemory

	; Clear StateData2 (16 bytes) - in separate memory page
	ld hl, wSpriteMistyStateData2
	ld bc, $10
	xor a
	call FillMemory

	; Set sprite picture ID
	ld a, SPRITE_MISTY
	ld [wSpriteMistyStateData1PictureID], a
	ld [wSpriteMistyStateData2PictureID], a

	; Set VRAM slot (ImageBaseOffset) - required for sprite to be processed
	ld a, $3  ; Misty is in VRAM slot 3 (after player=1, pikachu=2)
	ld [wSpriteMistyStateData2ImageBaseOffset], a

	; Set image index to $ff (will be updated on first spawn)
	ld a, $ff
	ld [wSpriteMistyStateData1ImageIndex], a

	; Clear movement status (will be set by InitializeMistyPosition)
	xor a
	ld [wSpriteMistyStateData1MovementStatus], a

	; Initialize position from trail
	call InitializeMistyPosition

	; Set initial image index (same calculation as UpdatePikachuWalkingSprite)
	; ImageIndex = (ImageBaseOffset - 1) << 4 | FacingDirection | AnimFrameCounter
	ld a, [wSpriteMistyStateData2ImageBaseOffset]
	dec a
	swap a  ; shift left by 4 bits
	and $f0  ; mask to upper 4 bits
	ld b, a
	ld a, [wSpriteMistyStateData1FacingDirection]
	or b
	ld [wSpriteMistyStateData1ImageIndex], a

	; Clear anim frame counter
	xor a
	ld [wSpriteMistyStateData1AnimFrameCounter], a

	ret

; =====================================
; BROCK INITIALIZATION (called from script)
; =====================================

InitializeBrockFollower::
; Called when Brock first starts following - clears state and initializes position
	; Initialize position trail first (sets up positions for all followers)
	call InitializePositionTrail

	; Clear state flags (ensures spawn conditions can pass)
	xor a
	ld [wBrockOverworldStateFlags], a

	; Clear StateData1 (16 bytes) - note: StateData1 and StateData2 are NOT contiguous
	ld hl, wSpriteBrockStateData1
	ld bc, $10
	xor a
	call FillMemory

	; Clear StateData2 (16 bytes) - in separate memory page
	ld hl, wSpriteBrockStateData2
	ld bc, $10
	xor a
	call FillMemory

	; Set sprite picture ID
	ld a, SPRITE_BROCK
	ld [wSpriteBrockStateData1PictureID], a
	ld [wSpriteBrockStateData2PictureID], a

	; Set VRAM slot (ImageBaseOffset) - required for sprite to be processed
	ld a, $4  ; Brock is in VRAM slot 4 (after player=1, pikachu=2, misty=3)
	ld [wSpriteBrockStateData2ImageBaseOffset], a

	; Set image index to $ff (will be updated on first spawn)
	ld a, $ff
	ld [wSpriteBrockStateData1ImageIndex], a

	; Clear movement status (will be set by InitializeBrockPosition)
	xor a
	ld [wSpriteBrockStateData1MovementStatus], a

	; Initialize position from trail
	call InitializeBrockPosition

	; Set initial image index (same calculation as UpdatePikachuWalkingSprite)
	; ImageIndex = (ImageBaseOffset - 1) << 4 | FacingDirection | AnimFrameCounter
	ld a, [wSpriteBrockStateData2ImageBaseOffset]
	dec a
	swap a  ; shift left by 4 bits
	and $f0  ; mask to upper 4 bits
	ld b, a
	ld a, [wSpriteBrockStateData1FacingDirection]
	or b
	ld [wSpriteBrockStateData1ImageIndex], a

	; Clear anim frame counter
	xor a
	ld [wSpriteBrockStateData1AnimFrameCounter], a

	ret

; =====================================
; HELPER: Initialize Follower Screen Position
; (This reuses existing InitializeSpriteScreenPosition)
; =====================================

; Note: The farcall to InitializeSpriteScreenPosition requires bc to point
; to the sprite's StateData1 base address
