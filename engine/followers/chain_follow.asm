; Chain Follower System - Misty and Brock
; Misty follows Pikachu, Brock follows Misty

; =====================================
; UNIFIED SPAWN DISPATCHER
; =====================================
; Called from home bank, dispatches to appropriate follower spawn function

SpawnFollower_::
	ldh a, [hCurrentSpriteOffset]
	cp $f0 ; pikachu (slot 15)
	jp z, SpawnPikachu_
	cp $e0 ; brock (slot 14)
	jp z, SpawnBrock_
	jp SpawnMisty_ ; misty (slot 13)

; =====================================
; MISTY FOLLOWER LOGIC
; =====================================
; Note: wSpriteMistyStateData1, wSpriteMistyStateData2, and all their field labels
; (e.g., wSpriteMistyStateData1MovementStatus, wSpriteMistyStateData2MapY, etc.)
; are automatically generated by the spritestatedata1/spritestatedata2 macros in wram.asm

; =====================================
; MISTY SPAWN CONDITION CHECK
; =====================================

ShouldMistySpawn::
; Returns carry if Misty should spawn
; Conditions: EVENT_MISTY_FOLLOWING_PLAYER is set, Pikachu is visible, not biking/surfing
	; Check if Misty following flag is set
	ld a, [wMistyOverworldStateFlags]
	bit 5, a
	jr nz, .hide
	bit 7, a
	jr nz, .hide

	; Check event flag (use full 16-bit offset since event is at $9F0)
	ld hl, wEventFlags
	ld de, EVENT_MISTY_FOLLOWING_PLAYER / 8
	add hl, de
	ld a, [hl]
	bit EVENT_MISTY_FOLLOWING_PLAYER % 8, a
	jr z, .hide

	; Check if Pikachu is spawned (movement status != 0)
	; TEMPORARILY DISABLED for debugging - uncomment when working
	; ld a, [wSpritePikachuStateData1MovementStatus]
	; and a
	; jr z, .hide

	; Check if not biking/surfing
	ld a, [wWalkBikeSurfState]
	and a
	jr nz, .hide

	scf
	ret

.hide
	and a
	ret

; =====================================
; BROCK SPAWN CONDITION CHECK
; =====================================

ShouldBrockSpawn::
; Returns carry if Brock should spawn
; Conditions: Has Boulder AND Cascade badges, Misty is visible, not biking/surfing
	; Check if Brock following flag overrides
	ld a, [wBrockOverworldStateFlags]
	bit 5, a
	jr nz, .hide
	bit 7, a
	jr nz, .hide

	; Check if has both Boulder and Cascade badges
	ld a, [wObtainedBadges]
	and (1 << BIT_BOULDERBADGE) | (1 << BIT_CASCADEBADGE)
	cp (1 << BIT_BOULDERBADGE) | (1 << BIT_CASCADEBADGE)
	jr nz, .hide

	; Check if Misty is spawned (movement status != 0)
	ld a, [wSpriteMistyStateData1MovementStatus]
	and a
	jr z, .hide

	; Check if not biking/surfing
	ld a, [wWalkBikeSurfState]
	and a
	jr nz, .hide

	scf
	ret

.hide
	and a
	ret

; =====================================
; MISTY MAIN SPAWN FUNCTION
; =====================================

SpawnMisty_::
	call ShouldMistySpawn
	jr c, .shouldSpawn

	; Shouldn't spawn - hide the sprite
	ld a, $ff
	ld [wSpriteMistyStateData1ImageIndex], a  ; Set ImageIndex to $ff (offscreen)
	xor a
	ld [wSpriteMistyStateData1MovementStatus], a  ; Set MovementStatus to 0
	ret

.shouldSpawn
	; Check if Misty already spawned
	ld a, [wSpriteMistyStateData1MovementStatus]
	and a
	jr nz, .alreadySpawned

	; Initialize Misty's spawn position (behind Pikachu)
	call InitializeMistyPosition

.alreadySpawned
	; Update Misty's movement based on state
	ld a, [wSpriteMistyStateData1MovementStatus]
	and $7f
	cp 3
	jr z, .doWalk
	cp 5
	jr z, .doWalk

	; Status 0 or 1 - just update and check commands
	call UpdateMistyIdleState
	ret

.doWalk
	call UpdateMistyWalking
	ret

; =====================================
; BROCK MAIN SPAWN FUNCTION
; =====================================

SpawnBrock_::
	call ShouldBrockSpawn
	jr c, .shouldSpawn

	; Shouldn't spawn - hide the sprite
	ld a, $ff
	ld [wSpriteBrockStateData1ImageIndex], a  ; Set ImageIndex to $ff (offscreen)
	xor a
	ld [wSpriteBrockStateData1MovementStatus], a  ; Set MovementStatus to 0
	ret

.shouldSpawn
	; Check if Brock already spawned
	ld a, [wSpriteBrockStateData1MovementStatus]
	and a
	jr nz, .alreadySpawned

	; Initialize Brock's spawn position (behind Misty)
	call InitializeBrockPosition

.alreadySpawned
	; Update Brock's movement based on state
	ld a, [wSpriteBrockStateData1MovementStatus]
	and $7f
	cp 3
	jr z, .doWalk
	cp 5
	jr z, .doWalk

	; Status 0 or 1 - just update and check commands
	call UpdateBrockIdleState
	ret

.doWalk
	call UpdateBrockWalking
	ret

; =====================================
; MISTY POSITION INITIALIZATION
; =====================================

InitializeMistyPosition:
	; Place Misty one tile behind Pikachu
	; Get Pikachu's position
	ld a, [wSpritePikachuStateData2MapY]
	ld b, a
	ld a, [wSpritePikachuStateData2MapX]
	ld c, a

	; Get Pikachu's facing direction to determine offset
	ld a, [wSpritePikachuStateData1FacingDirection]
	and a ; SPRITE_FACING_DOWN
	jr z, .placeAbove
	cp SPRITE_FACING_UP
	jr z, .placeBelow
	cp SPRITE_FACING_LEFT
	jr z, .placeRight
	; SPRITE_FACING_RIGHT - place left
	dec c
	jr .setPosition

.placeAbove
	dec b
	jr .setPosition

.placeBelow
	inc b
	jr .setPosition

.placeRight
	inc c

.setPosition
	; Set Misty's position
	ld a, b
	ld [wSpriteMistyStateData2MapY], a
	ld a, c
	ld [wSpriteMistyStateData2MapX], a

	; Set movement status to 1 (ready)
	ld a, 1
	ld [wSpriteMistyStateData1MovementStatus], a

	; Copy Pikachu's facing direction
	ld a, [wSpritePikachuStateData1FacingDirection]
	ld [wSpriteMistyStateData1FacingDirection], a

	; Clear command buffer
	call ClearMistyFollowCommandBuffer

	; Initialize screen position
	push bc
	ld bc, wSpriteMistyStateData1
	farcall InitializeSpriteScreenPosition
	pop bc
	ret

; =====================================
; BROCK POSITION INITIALIZATION
; =====================================

InitializeBrockPosition:
	; Place Brock one tile behind Misty
	; Get Misty's position
	ld a, [wSpriteMistyStateData2MapY]
	ld b, a
	ld a, [wSpriteMistyStateData2MapX]
	ld c, a

	; Get Misty's facing direction to determine offset
	ld a, [wSpriteMistyStateData1FacingDirection]
	and a ; SPRITE_FACING_DOWN
	jr z, .placeAbove
	cp SPRITE_FACING_UP
	jr z, .placeBelow
	cp SPRITE_FACING_LEFT
	jr z, .placeRight
	; SPRITE_FACING_RIGHT - place left
	dec c
	jr .setPosition

.placeAbove
	dec b
	jr .setPosition

.placeBelow
	inc b
	jr .setPosition

.placeRight
	inc c

.setPosition
	; Set Brock's position
	ld a, b
	ld [wSpriteBrockStateData2MapY], a
	ld a, c
	ld [wSpriteBrockStateData2MapX], a

	; Set movement status to 1 (ready)
	ld a, 1
	ld [wSpriteBrockStateData1MovementStatus], a

	; Copy Misty's facing direction
	ld a, [wSpriteMistyStateData1FacingDirection]
	ld [wSpriteBrockStateData1FacingDirection], a

	; Clear command buffer
	call ClearBrockFollowCommandBuffer

	; Initialize screen position
	push bc
	ld bc, wSpriteBrockStateData1
	farcall InitializeSpriteScreenPosition
	pop bc
	ret

; =====================================
; MISTY IDLE STATE UPDATE
; =====================================

UpdateMistyIdleState:
	; Check if there's a command in the buffer
	ld a, [wMistyFollowCommandBufferSize]
	cp $ff
	jr z, .noCommand

	; Get command and execute
	call GetMistyFollowCommand
	cp $ff
	jr z, .noCommand

	; Process movement command (1-4 = directions)
	dec a
	cp 4
	jr nc, .noCommand

	; Set facing direction and movement
	add a ; a * 2
	add a ; a * 4 (facing direction offset)
	ld [wSpriteMistyStateData1FacingDirection], a

	; Set movement status to 3 (walking)
	ld a, 3
	ld [wSpriteMistyStateData1MovementStatus], a

	; Set walk animation counter
	ld a, 8
	ld [wSpriteMistyStateData2WalkAnimationCounter], a

	; Set step vectors based on direction
	call SetMistyStepVector
	ret

.noCommand
	; Stay in idle, update screen position
	push bc
	ld bc, wSpriteMistyStateData1
	farcall InitializeSpriteScreenPosition
	pop bc
	ret

; =====================================
; BROCK IDLE STATE UPDATE
; =====================================

UpdateBrockIdleState:
	; Check if there's a command in the buffer
	ld a, [wBrockFollowCommandBufferSize]
	cp $ff
	jr z, .noCommand

	; Get command and execute
	call GetBrockFollowCommand
	cp $ff
	jr z, .noCommand

	; Process movement command (1-4 = directions)
	dec a
	cp 4
	jr nc, .noCommand

	; Set facing direction and movement
	add a ; a * 2
	add a ; a * 4 (facing direction offset)
	ld [wSpriteBrockStateData1FacingDirection], a

	; Set movement status to 3 (walking)
	ld a, 3
	ld [wSpriteBrockStateData1MovementStatus], a

	; Set walk animation counter
	ld a, 8
	ld [wSpriteBrockStateData2WalkAnimationCounter], a

	; Set step vectors based on direction
	call SetBrockStepVector
	ret

.noCommand
	; Stay in idle, update screen position
	push bc
	ld bc, wSpriteBrockStateData1
	farcall InitializeSpriteScreenPosition
	pop bc
	ret

; =====================================
; MISTY WALKING UPDATE
; =====================================

UpdateMistyWalking:
	; Decrement walk counter
	ld hl, wSpriteMistyStateData2WalkAnimationCounter
	dec [hl]
	jr nz, .continueWalk

	; Walk complete - update map position and return to idle
	call UpdateMistyMapPosition
	ld a, 1
	ld [wSpriteMistyStateData1MovementStatus], a

	; Clear step vectors
	xor a
	ld [wSpriteMistyStateData1 + SPRITESTATEDATA1_YSTEPVECTOR], a
	ld [wSpriteMistyStateData1 + SPRITESTATEDATA1_XSTEPVECTOR], a
	ret

.continueWalk
	; Update screen position during walk
	call UpdateMistyScreenPosition
	ret

; =====================================
; BROCK WALKING UPDATE
; =====================================

UpdateBrockWalking:
	; Decrement walk counter
	ld hl, wSpriteBrockStateData2WalkAnimationCounter
	dec [hl]
	jr nz, .continueWalk

	; Walk complete - update map position and return to idle
	call UpdateBrockMapPosition
	ld a, 1
	ld [wSpriteBrockStateData1MovementStatus], a

	; Clear step vectors
	xor a
	ld [wSpriteBrockStateData1 + SPRITESTATEDATA1_YSTEPVECTOR], a
	ld [wSpriteBrockStateData1 + SPRITESTATEDATA1_XSTEPVECTOR], a
	ret

.continueWalk
	; Update screen position during walk
	call UpdateBrockScreenPosition
	ret

; =====================================
; MISTY STEP VECTOR SETUP
; =====================================

SetMistyStepVector:
	ld a, [wSpriteMistyStateData1FacingDirection]
	and a ; SPRITE_FACING_DOWN (0)
	jr z, .down
	cp SPRITE_FACING_UP
	jr z, .up
	cp SPRITE_FACING_LEFT
	jr z, .left
	; RIGHT
	ld a, 1
	ld [wSpriteMistyStateData1 + SPRITESTATEDATA1_XSTEPVECTOR], a
	xor a
	ld [wSpriteMistyStateData1 + SPRITESTATEDATA1_YSTEPVECTOR], a
	ret

.down
	ld a, 1
	ld [wSpriteMistyStateData1 + SPRITESTATEDATA1_YSTEPVECTOR], a
	xor a
	ld [wSpriteMistyStateData1 + SPRITESTATEDATA1_XSTEPVECTOR], a
	ret

.up
	ld a, -1
	ld [wSpriteMistyStateData1 + SPRITESTATEDATA1_YSTEPVECTOR], a
	xor a
	ld [wSpriteMistyStateData1 + SPRITESTATEDATA1_XSTEPVECTOR], a
	ret

.left
	ld a, -1
	ld [wSpriteMistyStateData1 + SPRITESTATEDATA1_XSTEPVECTOR], a
	xor a
	ld [wSpriteMistyStateData1 + SPRITESTATEDATA1_YSTEPVECTOR], a
	ret

; =====================================
; BROCK STEP VECTOR SETUP
; =====================================

SetBrockStepVector:
	ld a, [wSpriteBrockStateData1FacingDirection]
	and a ; SPRITE_FACING_DOWN (0)
	jr z, .down
	cp SPRITE_FACING_UP
	jr z, .up
	cp SPRITE_FACING_LEFT
	jr z, .left
	; RIGHT
	ld a, 1
	ld [wSpriteBrockStateData1 + SPRITESTATEDATA1_XSTEPVECTOR], a
	xor a
	ld [wSpriteBrockStateData1 + SPRITESTATEDATA1_YSTEPVECTOR], a
	ret

.down
	ld a, 1
	ld [wSpriteBrockStateData1 + SPRITESTATEDATA1_YSTEPVECTOR], a
	xor a
	ld [wSpriteBrockStateData1 + SPRITESTATEDATA1_XSTEPVECTOR], a
	ret

.up
	ld a, -1
	ld [wSpriteBrockStateData1 + SPRITESTATEDATA1_YSTEPVECTOR], a
	xor a
	ld [wSpriteBrockStateData1 + SPRITESTATEDATA1_XSTEPVECTOR], a
	ret

.left
	ld a, -1
	ld [wSpriteBrockStateData1 + SPRITESTATEDATA1_XSTEPVECTOR], a
	xor a
	ld [wSpriteBrockStateData1 + SPRITESTATEDATA1_YSTEPVECTOR], a
	ret

; =====================================
; MISTY MAP POSITION UPDATE
; =====================================

UpdateMistyMapPosition:
	; Update map Y
	ld a, [wSpriteMistyStateData1 + SPRITESTATEDATA1_YSTEPVECTOR]
	ld b, a
	ld a, [wSpriteMistyStateData2MapY]
	add b
	ld [wSpriteMistyStateData2MapY], a

	; Update map X
	ld a, [wSpriteMistyStateData1 + SPRITESTATEDATA1_XSTEPVECTOR]
	ld b, a
	ld a, [wSpriteMistyStateData2MapX]
	add b
	ld [wSpriteMistyStateData2MapX], a
	ret

; =====================================
; BROCK MAP POSITION UPDATE
; =====================================

UpdateBrockMapPosition:
	; Update map Y
	ld a, [wSpriteBrockStateData1 + SPRITESTATEDATA1_YSTEPVECTOR]
	ld b, a
	ld a, [wSpriteBrockStateData2MapY]
	add b
	ld [wSpriteBrockStateData2MapY], a

	; Update map X
	ld a, [wSpriteBrockStateData1 + SPRITESTATEDATA1_XSTEPVECTOR]
	ld b, a
	ld a, [wSpriteBrockStateData2MapX]
	add b
	ld [wSpriteBrockStateData2MapX], a
	ret

; =====================================
; MISTY SCREEN POSITION UPDATE
; =====================================

UpdateMistyScreenPosition:
	; Update Y pixel position
	ld a, [wSpriteMistyStateData1 + SPRITESTATEDATA1_YSTEPVECTOR]
	ld b, a
	add a ; double for 2 pixels per frame
	ld b, a
	ld a, [wSpriteMistyStateData1 + SPRITESTATEDATA1_YPIXELS]
	add b
	ld [wSpriteMistyStateData1 + SPRITESTATEDATA1_YPIXELS], a

	; Update X pixel position
	ld a, [wSpriteMistyStateData1 + SPRITESTATEDATA1_XSTEPVECTOR]
	add a ; double for 2 pixels per frame
	ld b, a
	ld a, [wSpriteMistyStateData1 + SPRITESTATEDATA1_XPIXELS]
	add b
	ld [wSpriteMistyStateData1 + SPRITESTATEDATA1_XPIXELS], a
	ret

; =====================================
; BROCK SCREEN POSITION UPDATE
; =====================================

UpdateBrockScreenPosition:
	; Update Y pixel position
	ld a, [wSpriteBrockStateData1 + SPRITESTATEDATA1_YSTEPVECTOR]
	add a ; double for 2 pixels per frame
	ld b, a
	ld a, [wSpriteBrockStateData1 + SPRITESTATEDATA1_YPIXELS]
	add b
	ld [wSpriteBrockStateData1 + SPRITESTATEDATA1_YPIXELS], a

	; Update X pixel position
	ld a, [wSpriteBrockStateData1 + SPRITESTATEDATA1_XSTEPVECTOR]
	add a ; double for 2 pixels per frame
	ld b, a
	ld a, [wSpriteBrockStateData1 + SPRITESTATEDATA1_XPIXELS]
	add b
	ld [wSpriteBrockStateData1 + SPRITESTATEDATA1_XPIXELS], a
	ret

; =====================================
; MISTY COMMAND BUFFER MANAGEMENT
; =====================================

ClearMistyFollowCommandBuffer:
	ld hl, wMistyFollowCommandBufferSize
	ld [hl], $ff
	inc hl
	ld bc, 4  ; reduced to match buffer size
	xor a
	call FillMemory
	ret

AppendMistyFollowCommand::
; Called when player moves - compute and append command for Misty to follow Pikachu
	call ShouldMistySpawn
	ret nc

	; Compute direction from Misty to Pikachu
	call ComputeMistyFollowCommand
	ret c ; No movement needed

	; Append to buffer
	ld hl, wMistyFollowCommandBufferSize
	ld b, [hl]
	inc b
	cp 4 ; Buffer full check (minimal size to save WRAM)
	ret nc
	ld [hl], b
	ld e, b
	ld d, 0
	ld hl, wMistyFollowCommandBuffer
	add hl, de
	ld [hl], a
	ret

GetMistyFollowCommand:
	ld hl, wMistyFollowCommandBufferSize
	ld a, [hl]
	cp $ff
	jr z, .empty

	; Get command at index 0
	inc hl
	ld a, [hl]
	push af

	; Shift buffer down
	ld de, wMistyFollowCommandBuffer
	ld hl, wMistyFollowCommandBuffer + 1
	ld bc, 3  ; reduced to match 4-byte buffer
	call CopyData

	; Decrement size
	ld hl, wMistyFollowCommandBufferSize
	ld a, [hl]
	and a
	jr z, .setEmpty
	dec a
	ld [hl], a
	pop af
	ret

.setEmpty
	ld [hl], $ff
	pop af
	ret

.empty
	ld a, $ff
	ret

; =====================================
; BROCK COMMAND BUFFER MANAGEMENT
; =====================================

ClearBrockFollowCommandBuffer:
	ld hl, wBrockFollowCommandBufferSize
	ld [hl], $ff
	inc hl
	ld bc, 4  ; reduced to match buffer size
	xor a
	call FillMemory
	ret

AppendBrockFollowCommand::
; Called when player moves - compute and append command for Brock to follow Misty
	call ShouldBrockSpawn
	ret nc

	; Compute direction from Brock to Misty
	call ComputeBrockFollowCommand
	ret c ; No movement needed

	; Append to buffer
	ld hl, wBrockFollowCommandBufferSize
	ld b, [hl]
	inc b
	cp 4 ; Buffer full check (minimal size to save WRAM)
	ret nc
	ld [hl], b
	ld e, b
	ld d, 0
	ld hl, wBrockFollowCommandBuffer
	add hl, de
	ld [hl], a
	ret

GetBrockFollowCommand:
	ld hl, wBrockFollowCommandBufferSize
	ld a, [hl]
	cp $ff
	jr z, .empty

	; Get command at index 0
	inc hl
	ld a, [hl]
	push af

	; Shift buffer down
	ld de, wBrockFollowCommandBuffer
	ld hl, wBrockFollowCommandBuffer + 1
	ld bc, 3  ; reduced to match 4-byte buffer
	call CopyData

	; Decrement size
	ld hl, wBrockFollowCommandBufferSize
	ld a, [hl]
	and a
	jr z, .setEmpty
	dec a
	ld [hl], a
	pop af
	ret

.setEmpty
	ld [hl], $ff
	pop af
	ret

.empty
	ld a, $ff
	ret

; =====================================
; MISTY FOLLOW COMMAND COMPUTATION
; =====================================

ComputeMistyFollowCommand:
; Compute direction from Misty to Pikachu
; Returns: a = command (1=down, 2=up, 3=left, 4=right), carry set if no movement needed
	; Compare Y coordinates
	ld a, [wSpritePikachuStateData2MapY]
	ld b, a
	ld a, [wSpriteMistyStateData2MapY]
	sub b
	jr z, .checkX
	jr c, .mistyAbovePikachu

	; Misty is below Pikachu - move up
	ld a, 2
	and a
	ret

.mistyAbovePikachu
	; Misty is above Pikachu - move down
	ld a, 1
	and a
	ret

.checkX
	; Y coords equal - check X
	ld a, [wSpritePikachuStateData2MapX]
	ld b, a
	ld a, [wSpriteMistyStateData2MapX]
	sub b
	jr z, .onTop
	jr c, .mistyLeftOfPikachu

	; Misty is right of Pikachu - move left
	ld a, 3
	and a
	ret

.mistyLeftOfPikachu
	; Misty is left of Pikachu - move right
	ld a, 4
	and a
	ret

.onTop
	; Already on target
	scf
	ret

; =====================================
; BROCK FOLLOW COMMAND COMPUTATION
; =====================================

ComputeBrockFollowCommand:
; Compute direction from Brock to Misty
; Returns: a = command (1=down, 2=up, 3=left, 4=right), carry set if no movement needed
	; Compare Y coordinates
	ld a, [wSpriteMistyStateData2MapY]
	ld b, a
	ld a, [wSpriteBrockStateData2MapY]
	sub b
	jr z, .checkX
	jr c, .brockAboveMisty

	; Brock is below Misty - move up
	ld a, 2
	and a
	ret

.brockAboveMisty
	; Brock is above Misty - move down
	ld a, 1
	and a
	ret

.checkX
	; Y coords equal - check X
	ld a, [wSpriteMistyStateData2MapX]
	ld b, a
	ld a, [wSpriteBrockStateData2MapX]
	sub b
	jr z, .onTop
	jr c, .brockLeftOfMisty

	; Brock is right of Misty - move left
	ld a, 3
	and a
	ret

.brockLeftOfMisty
	; Brock is left of Misty - move right
	ld a, 4
	and a
	ret

.onTop
	; Already on target
	scf
	ret

; =====================================
; MISTY INITIALIZATION (called from script)
; =====================================

InitializeMistyFollower::
; Called when Misty first starts following - clears state and initializes position
	; Clear state flags (ensures spawn conditions can pass)
	xor a
	ld [wMistyOverworldStateFlags], a

	; Clear StateData1 (16 bytes) - note: StateData1 and StateData2 are NOT contiguous
	ld hl, wSpriteMistyStateData1
	ld bc, $10
	xor a
	call FillMemory

	; Clear StateData2 (16 bytes) - in separate memory page
	ld hl, wSpriteMistyStateData2
	ld bc, $10
	xor a
	call FillMemory

	; Set sprite picture ID
	ld a, SPRITE_BRUNETTE_GIRL
	ld [wSpriteMistyStateData1PictureID], a
	ld [wSpriteMistyStateData2PictureID], a

	; Set VRAM slot (ImageBaseOffset) - required for sprite to be processed
	ld a, $3  ; Misty is in VRAM slot 3 (after player=1, pikachu=2)
	ld [wSpriteMistyStateData2ImageBaseOffset], a

	; Set image index to $ff (will be updated on first spawn)
	ld a, $ff
	ld [wSpriteMistyStateData1ImageIndex], a

	; Clear movement status (will be set by InitializeMistyPosition)
	xor a
	ld [wSpriteMistyStateData1MovementStatus], a

	; Clear command buffer
	call ClearMistyFollowCommandBuffer

	; Initialize position (behind Pikachu)
	call InitializeMistyPosition

	; Set initial image index (same calculation as UpdatePikachuWalkingSprite)
	; ImageIndex = (ImageBaseOffset - 1) << 4 | FacingDirection | AnimFrameCounter
	ld a, [wSpriteMistyStateData2ImageBaseOffset]
	dec a
	swap a  ; shift left by 4 bits
	and $f0  ; mask to upper 4 bits
	ld b, a
	ld a, [wSpriteMistyStateData1FacingDirection]
	or b
	ld [wSpriteMistyStateData1ImageIndex], a

	; Clear anim frame counter
	xor a
	ld [wSpriteMistyStateData1AnimFrameCounter], a

	ret

; =====================================
; HELPER: Initialize Follower Screen Position
; (This reuses existing InitializeSpriteScreenPosition)
; =====================================

; Note: The farcall to InitializeSpriteScreenPosition requires bc to point
; to the sprite's StateData1 base address
