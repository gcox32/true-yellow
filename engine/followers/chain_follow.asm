; Chain Follower System - Misty and Brock
; Misty follows Pikachu, Brock follows Misty

; =====================================
; UNIFIED SPAWN DISPATCHER
; =====================================
; Called from home bank, dispatches to appropriate follower spawn function

SpawnFollower_::
	ldh a, [hCurrentSpriteOffset]
	cp $f0 ; pikachu (slot 15)
	jp z, SpawnPikachu_
	cp $e0 ; brock (slot 14)
	jp z, SpawnBrock_
	jp SpawnMisty_ ; misty (slot 13)

; =====================================
; MISTY FOLLOWER LOGIC
; =====================================
; Note: wSpriteMistyStateData1, wSpriteMistyStateData2, and all their field labels
; (e.g., wSpriteMistyStateData1MovementStatus, wSpriteMistyStateData2MapY, etc.)
; are automatically generated by the spritestatedata1/spritestatedata2 macros in wram.asm

; =====================================
; MISTY SPAWN CONDITION CHECK
; =====================================

ShouldMistySpawn::
; Returns carry if Misty should spawn
; Conditions: EVENT_MISTY_FOLLOWING_PLAYER is set, Pikachu is visible, not biking/surfing
	; Check if Misty following flag is set
	ld a, [wMistyOverworldStateFlags]
	bit 5, a
	jr nz, .hide
	bit 7, a
	jr nz, .hide

	; Check event flag (use full 16-bit offset since event is at $9F0)
	ld hl, wEventFlags
	ld de, EVENT_MISTY_FOLLOWING_PLAYER / 8
	add hl, de
	ld a, [hl]
	bit EVENT_MISTY_FOLLOWING_PLAYER % 8, a
	jr z, .hide

	; Check if Pikachu is spawned (movement status != 0)
	; TEMPORARILY DISABLED for debugging - uncomment when working
	; ld a, [wSpritePikachuStateData1MovementStatus]
	; and a
	; jr z, .hide

	; Check if not biking/surfing
	ld a, [wWalkBikeSurfState]
	and a
	jr nz, .hide

	scf
	ret

.hide
	and a
	ret

; =====================================
; BROCK SPAWN CONDITION CHECK
; =====================================

ShouldBrockSpawn::
; Returns carry if Brock should spawn
; Conditions: Has Boulder AND Cascade badges, Misty is visible, not biking/surfing
	; Check if Brock following flag overrides
	ld a, [wBrockOverworldStateFlags]
	bit 5, a
	jr nz, .hide
	bit 7, a
	jr nz, .hide

	; Check if has both Boulder and Cascade badges
	ld a, [wObtainedBadges]
	and (1 << BIT_BOULDERBADGE) | (1 << BIT_CASCADEBADGE)
	cp (1 << BIT_BOULDERBADGE) | (1 << BIT_CASCADEBADGE)
	jr nz, .hide

	; Check if Misty is spawned (movement status != 0)
	ld a, [wSpriteMistyStateData1MovementStatus]
	and a
	jr z, .hide

	; Check if not biking/surfing
	ld a, [wWalkBikeSurfState]
	and a
	jr nz, .hide

	scf
	ret

.hide
	and a
	ret

; =====================================
; MISTY MAIN SPAWN FUNCTION
; =====================================

SpawnMisty_::
	call ShouldMistySpawn
	jr c, .shouldSpawn

	; Shouldn't spawn - hide the sprite
	ld a, $ff
	ld [wSpriteMistyStateData1ImageIndex], a  ; Set ImageIndex to $ff (offscreen)
	xor a
	ld [wSpriteMistyStateData1MovementStatus], a  ; Set MovementStatus to 0
	ret

.shouldSpawn
	; Check if Misty already spawned
	ld a, [wSpriteMistyStateData1MovementStatus]
	and a
	jr nz, .alreadySpawned

	; Initialize Misty's spawn position (behind Pikachu)
	call InitializeMistyPosition

.alreadySpawned
	; Update Misty's movement based on state
	ld a, [wSpriteMistyStateData1MovementStatus]
	and $7f
	cp 3
	jr z, .doWalk
	cp 5
	jr z, .doWalk

	; Status 0 or 1 - just update and check commands
	call UpdateMistyIdleState
	ret

.doWalk
	call UpdateMistyWalking
	ret

; =====================================
; BROCK MAIN SPAWN FUNCTION
; =====================================

SpawnBrock_::
	call ShouldBrockSpawn
	jr c, .shouldSpawn

	; Shouldn't spawn - hide the sprite
	ld a, $ff
	ld [wSpriteBrockStateData1ImageIndex], a  ; Set ImageIndex to $ff (offscreen)
	xor a
	ld [wSpriteBrockStateData1MovementStatus], a  ; Set MovementStatus to 0
	ret

.shouldSpawn
	; Check if Brock already spawned
	ld a, [wSpriteBrockStateData1MovementStatus]
	and a
	jr nz, .alreadySpawned

	; Initialize Brock's spawn position (behind Misty)
	call InitializeBrockPosition

.alreadySpawned
	; Update Brock's movement based on state
	ld a, [wSpriteBrockStateData1MovementStatus]
	and $7f
	cp 3
	jr z, .doWalk
	cp 5
	jr z, .doWalk

	; Status 0 or 1 - just update and check commands
	call UpdateBrockIdleState
	ret

.doWalk
	call UpdateBrockWalking
	ret

; =====================================
; MISTY POSITION INITIALIZATION
; =====================================

InitializeMistyPosition:
	; Place Misty one tile behind Pikachu
	; First ensure PictureID and ImageBaseOffset are set (required for sprite to be processed)
	ld a, SPRITE_BRUNETTE_GIRL
	ld [wSpriteMistyStateData1PictureID], a
	ld [wSpriteMistyStateData2PictureID], a
	
	; Set VRAM slot (ImageBaseOffset) - required for sprite to be processed
	ld a, $3  ; Misty is in VRAM slot 3 (after player=1, pikachu=2)
	ld [wSpriteMistyStateData2ImageBaseOffset], a
	
	; Get Pikachu's position
	ld a, [wSpritePikachuStateData2MapY]
	ld b, a
	ld a, [wSpritePikachuStateData2MapX]
	ld c, a

	; Get Pikachu's facing direction to determine offset
	ld a, [wSpritePikachuStateData1FacingDirection]
	and a ; SPRITE_FACING_DOWN
	jr z, .placeAbove
	cp SPRITE_FACING_UP
	jr z, .placeBelow
	cp SPRITE_FACING_LEFT
	jr z, .placeRight
	; SPRITE_FACING_RIGHT - place left
	dec c
	jr .setPosition

.placeAbove
	dec b
	jr .setPosition

.placeBelow
	inc b
	jr .setPosition

.placeRight
	inc c

.setPosition
	; Set Misty's position
	ld a, b
	ld [wSpriteMistyStateData2MapY], a
	ld a, c
	ld [wSpriteMistyStateData2MapX], a

	; Set movement status to 1 (ready)
	ld a, 1
	ld [wSpriteMistyStateData1MovementStatus], a

	; Copy Pikachu's facing direction
	ld a, [wSpritePikachuStateData1FacingDirection]
	ld [wSpriteMistyStateData1FacingDirection], a

	; Clear command buffer
	call ClearMistyFollowCommandBuffer

	; Initialize screen position
	push bc
	ld bc, wSpriteMistyStateData1
	farcall InitializeSpriteScreenPosition
	pop bc
	
	; Set initial image index (same calculation as UpdatePikachuWalkingSprite)
	; ImageIndex = (ImageBaseOffset - 1) << 4 | FacingDirection | AnimFrameCounter
	ld a, [wSpriteMistyStateData2ImageBaseOffset]
	dec a
	swap a  ; shift left by 4 bits
	and $f0  ; mask to upper 4 bits
	ld b, a
	ld a, [wSpriteMistyStateData1FacingDirection]
	or b
	ld [wSpriteMistyStateData1ImageIndex], a
	
	ret

; =====================================
; BROCK POSITION INITIALIZATION
; =====================================

InitializeBrockPosition:
	; Place Brock one tile behind Misty
	; First ensure PictureID and ImageBaseOffset are set (required for sprite to be processed)
	ld a, SPRITE_HIKER
	ld [wSpriteBrockStateData1PictureID], a
	ld [wSpriteBrockStateData2PictureID], a
	
	; Set VRAM slot (ImageBaseOffset) - required for sprite to be processed
	; Note: Brock would need a VRAM slot, but since we don't have one reserved yet,
	; we'll use a slot that's available. For now, we'll need to add Brock to the sprite set.
	; TODO: Add Brock's sprite to sprite sets and assign proper VRAM slot
	ld a, $4  ; Temporary VRAM slot (will need proper assignment)
	ld [wSpriteBrockStateData2ImageBaseOffset], a
	
	; Get Misty's position
	ld a, [wSpriteMistyStateData2MapY]
	ld b, a
	ld a, [wSpriteMistyStateData2MapX]
	ld c, a

	; Get Misty's facing direction to determine offset
	ld a, [wSpriteMistyStateData1FacingDirection]
	and a ; SPRITE_FACING_DOWN
	jr z, .placeAbove
	cp SPRITE_FACING_UP
	jr z, .placeBelow
	cp SPRITE_FACING_LEFT
	jr z, .placeRight
	; SPRITE_FACING_RIGHT - place left
	dec c
	jr .setPosition

.placeAbove
	dec b
	jr .setPosition

.placeBelow
	inc b
	jr .setPosition

.placeRight
	inc c

.setPosition
	; Set Brock's position
	ld a, b
	ld [wSpriteBrockStateData2MapY], a
	ld a, c
	ld [wSpriteBrockStateData2MapX], a

	; Set movement status to 1 (ready)
	ld a, 1
	ld [wSpriteBrockStateData1MovementStatus], a

	; Copy Misty's facing direction
	ld a, [wSpriteMistyStateData1FacingDirection]
	ld [wSpriteBrockStateData1FacingDirection], a

	; Clear command buffer
	call ClearBrockFollowCommandBuffer

	; Initialize screen position
	push bc
	ld bc, wSpriteBrockStateData1
	farcall InitializeSpriteScreenPosition
	pop bc
	
	; Set initial image index (same calculation as UpdatePikachuWalkingSprite)
	; ImageIndex = (ImageBaseOffset - 1) << 4 | FacingDirection | AnimFrameCounter
	ld a, [wSpriteBrockStateData2ImageBaseOffset]
	dec a
	swap a  ; shift left by 4 bits
	and $f0  ; mask to upper 4 bits
	ld b, a
	ld a, [wSpriteBrockStateData1FacingDirection]
	or b
	ld [wSpriteBrockStateData1ImageIndex], a
	
	ret

; =====================================
; MISTY IDLE STATE UPDATE
; =====================================

UpdateMistyIdleState:
; Real-time relative positioning: compute direction toward Pikachu NOW
; No buffering - just check if we need to move and do it
	; Compute direction from Misty to Pikachu (returns 1-4 normal, 5-8 fast)
	call ComputeMistyFollowCommand
	jr c, .noMovementNeeded  ; carry = already at target

	; Process movement command (1-4 = normal, 5-8 = fast)
	ld b, a  ; save command
	dec a    ; 0-7
	cp 4
	jr c, .normalSpeed

	; Fast movement (command 5-8)
	sub 4    ; convert 5-8 to 0-3 (direction)
	add a    ; * 2
	add a    ; * 4 (facing direction offset)
	ld [wSpriteMistyStateData1FacingDirection], a

	; Set movement status to 5 (fast walking)
	ld a, 5
	ld [wSpriteMistyStateData1MovementStatus], a

	; Set walk animation counter (4 frames = faster)
	ld a, 4
	ld [wSpriteMistyStateData2WalkAnimationCounter], a

	; Set step vectors based on direction
	call SetMistyStepVector
	ret

.normalSpeed
	; Normal movement (command 1-4)
	; a is already 0-3
	add a    ; * 2
	add a    ; * 4 (facing direction offset)
	ld [wSpriteMistyStateData1FacingDirection], a

	; Set movement status to 3 (walking)
	ld a, 3
	ld [wSpriteMistyStateData1MovementStatus], a

	; Set walk animation counter (8 frames = normal)
	ld a, 8
	ld [wSpriteMistyStateData2WalkAnimationCounter], a

	; Set step vectors based on direction
	call SetMistyStepVector
	ret

.noMovementNeeded
	; Stay in idle, update screen position and facing direction
	push bc
	ld bc, wSpriteMistyStateData1
	farcall InitializeSpriteScreenPosition
	pop bc

	; Update facing direction based on position relative to Pikachu
	call ComputeMistyFacingDirection

	; Update sprite image index
	call UpdateMistyWalkingSprite
	ret

; =====================================
; BROCK IDLE STATE UPDATE
; =====================================

UpdateBrockIdleState:
; Real-time relative positioning: compute direction toward Misty NOW
; No buffering - just check if we need to move and do it
	; Compute direction from Brock to Misty (returns 1-4 normal, 5-8 fast)
	call ComputeBrockFollowCommand
	jr c, .noMovementNeeded  ; carry = already at target

	; Process movement command (1-4 = normal, 5-8 = fast)
	ld b, a  ; save command
	dec a    ; 0-7
	cp 4
	jr c, .normalSpeed

	; Fast movement (command 5-8)
	sub 4    ; convert 5-8 to 0-3 (direction)
	add a    ; * 2
	add a    ; * 4 (facing direction offset)
	ld [wSpriteBrockStateData1FacingDirection], a

	; Set movement status to 5 (fast walking)
	ld a, 5
	ld [wSpriteBrockStateData1MovementStatus], a

	; Set walk animation counter (4 frames = faster)
	ld a, 4
	ld [wSpriteBrockStateData2WalkAnimationCounter], a

	; Set step vectors based on direction
	call SetBrockStepVector
	ret

.normalSpeed
	; Normal movement (command 1-4)
	; a is already 0-3
	add a    ; * 2
	add a    ; * 4 (facing direction offset)
	ld [wSpriteBrockStateData1FacingDirection], a

	; Set movement status to 3 (walking)
	ld a, 3
	ld [wSpriteBrockStateData1MovementStatus], a

	; Set walk animation counter (8 frames = normal)
	ld a, 8
	ld [wSpriteBrockStateData2WalkAnimationCounter], a

	; Set step vectors based on direction
	call SetBrockStepVector
	ret

.noMovementNeeded
	; Stay in idle, update screen position
	push bc
	ld bc, wSpriteBrockStateData1
	farcall InitializeSpriteScreenPosition
	pop bc
	ret

; =====================================
; MISTY WALKING UPDATE
; =====================================

UpdateMistyWalking:
	; Decrement walk counter
	ld hl, wSpriteMistyStateData2WalkAnimationCounter
	dec [hl]
	jr nz, .continueWalk

	; Walk complete - update map position and return to idle
	call UpdateMistyMapPosition

	; Clear step vectors
	xor a
	ld [wSpriteMistyStateData1 + SPRITESTATEDATA1_YSTEPVECTOR], a
	ld [wSpriteMistyStateData1 + SPRITESTATEDATA1_XSTEPVECTOR], a

	; Recompute facing direction based on position relative to Pikachu
	call ComputeMistyFacingDirection

	; Return to idle state
	ld a, 1
	ld [wSpriteMistyStateData1MovementStatus], a
	ret

.continueWalk
	; Check if fast walking (status 5) or normal (status 3)
	ld a, [wSpriteMistyStateData1MovementStatus]
	and $7f
	cp 5
	jr z, .fastWalk

	; Normal walk - 2 pixels per frame
	call UpdateMistyScreenPosition
	jr .updateSprite

.fastWalk
	; Fast walk - 4 pixels per frame (call twice)
	call UpdateMistyScreenPosition
	call UpdateMistyScreenPosition

.updateSprite
	; Update sprite image index during walk
	call UpdateMistyWalkingSprite
	ret

; =====================================
; BROCK WALKING UPDATE
; =====================================

UpdateBrockWalking:
	; Decrement walk counter
	ld hl, wSpriteBrockStateData2WalkAnimationCounter
	dec [hl]
	jr nz, .continueWalk

	; Walk complete - update map position and return to idle
	call UpdateBrockMapPosition
	ld a, 1
	ld [wSpriteBrockStateData1MovementStatus], a

	; Clear step vectors
	xor a
	ld [wSpriteBrockStateData1 + SPRITESTATEDATA1_YSTEPVECTOR], a
	ld [wSpriteBrockStateData1 + SPRITESTATEDATA1_XSTEPVECTOR], a
	ret

.continueWalk
	; Check if fast walking (status 5) or normal (status 3)
	ld a, [wSpriteBrockStateData1MovementStatus]
	and $7f
	cp 5
	jr z, .fastWalk

	; Normal walk - 2 pixels per frame
	call UpdateBrockScreenPosition
	ret

.fastWalk
	; Fast walk - 4 pixels per frame (call twice)
	call UpdateBrockScreenPosition
	call UpdateBrockScreenPosition
	ret

; =====================================
; MISTY STEP VECTOR SETUP
; =====================================

SetMistyStepVector:
	ld a, [wSpriteMistyStateData1FacingDirection]
	and a ; SPRITE_FACING_DOWN (0)
	jr z, .down
	cp SPRITE_FACING_UP
	jr z, .up
	cp SPRITE_FACING_LEFT
	jr z, .left
	; RIGHT
	ld a, 1
	ld [wSpriteMistyStateData1 + SPRITESTATEDATA1_XSTEPVECTOR], a
	xor a
	ld [wSpriteMistyStateData1 + SPRITESTATEDATA1_YSTEPVECTOR], a
	ret

.down
	ld a, 1
	ld [wSpriteMistyStateData1 + SPRITESTATEDATA1_YSTEPVECTOR], a
	xor a
	ld [wSpriteMistyStateData1 + SPRITESTATEDATA1_XSTEPVECTOR], a
	ret

.up
	ld a, -1
	ld [wSpriteMistyStateData1 + SPRITESTATEDATA1_YSTEPVECTOR], a
	xor a
	ld [wSpriteMistyStateData1 + SPRITESTATEDATA1_XSTEPVECTOR], a
	ret

.left
	ld a, -1
	ld [wSpriteMistyStateData1 + SPRITESTATEDATA1_XSTEPVECTOR], a
	xor a
	ld [wSpriteMistyStateData1 + SPRITESTATEDATA1_YSTEPVECTOR], a
	ret

; =====================================
; BROCK STEP VECTOR SETUP
; =====================================

SetBrockStepVector:
	ld a, [wSpriteBrockStateData1FacingDirection]
	and a ; SPRITE_FACING_DOWN (0)
	jr z, .down
	cp SPRITE_FACING_UP
	jr z, .up
	cp SPRITE_FACING_LEFT
	jr z, .left
	; RIGHT
	ld a, 1
	ld [wSpriteBrockStateData1 + SPRITESTATEDATA1_XSTEPVECTOR], a
	xor a
	ld [wSpriteBrockStateData1 + SPRITESTATEDATA1_YSTEPVECTOR], a
	ret

.down
	ld a, 1
	ld [wSpriteBrockStateData1 + SPRITESTATEDATA1_YSTEPVECTOR], a
	xor a
	ld [wSpriteBrockStateData1 + SPRITESTATEDATA1_XSTEPVECTOR], a
	ret

.up
	ld a, -1
	ld [wSpriteBrockStateData1 + SPRITESTATEDATA1_YSTEPVECTOR], a
	xor a
	ld [wSpriteBrockStateData1 + SPRITESTATEDATA1_XSTEPVECTOR], a
	ret

.left
	ld a, -1
	ld [wSpriteBrockStateData1 + SPRITESTATEDATA1_XSTEPVECTOR], a
	xor a
	ld [wSpriteBrockStateData1 + SPRITESTATEDATA1_YSTEPVECTOR], a
	ret

; =====================================
; MISTY MAP POSITION UPDATE
; =====================================

UpdateMistyMapPosition:
	; Update map Y
	ld a, [wSpriteMistyStateData1 + SPRITESTATEDATA1_YSTEPVECTOR]
	ld b, a
	ld a, [wSpriteMistyStateData2MapY]
	add b
	ld [wSpriteMistyStateData2MapY], a

	; Update map X
	ld a, [wSpriteMistyStateData1 + SPRITESTATEDATA1_XSTEPVECTOR]
	ld b, a
	ld a, [wSpriteMistyStateData2MapX]
	add b
	ld [wSpriteMistyStateData2MapX], a
	ret

; =====================================
; BROCK MAP POSITION UPDATE
; =====================================

UpdateBrockMapPosition:
	; Update map Y
	ld a, [wSpriteBrockStateData1 + SPRITESTATEDATA1_YSTEPVECTOR]
	ld b, a
	ld a, [wSpriteBrockStateData2MapY]
	add b
	ld [wSpriteBrockStateData2MapY], a

	; Update map X
	ld a, [wSpriteBrockStateData1 + SPRITESTATEDATA1_XSTEPVECTOR]
	ld b, a
	ld a, [wSpriteBrockStateData2MapX]
	add b
	ld [wSpriteBrockStateData2MapX], a
	ret

; =====================================
; MISTY SCREEN POSITION UPDATE
; =====================================

UpdateMistyScreenPosition:
	; Update Y pixel position (2 pixels per frame)
	ld a, [wSpriteMistyStateData1 + SPRITESTATEDATA1_YSTEPVECTOR]
	add a ; double for 2 pixels per frame
	ld b, a
	ld a, [wSpriteMistyStateData1 + SPRITESTATEDATA1_YPIXELS]
	add b
	ld [wSpriteMistyStateData1 + SPRITESTATEDATA1_YPIXELS], a

	; Update X pixel position (2 pixels per frame)
	ld a, [wSpriteMistyStateData1 + SPRITESTATEDATA1_XSTEPVECTOR]
	add a ; double for 2 pixels per frame
	ld b, a
	ld a, [wSpriteMistyStateData1 + SPRITESTATEDATA1_XPIXELS]
	add b
	ld [wSpriteMistyStateData1 + SPRITESTATEDATA1_XPIXELS], a
	ret

; =====================================
; BROCK SCREEN POSITION UPDATE
; =====================================

UpdateBrockScreenPosition:
	; Update Y pixel position
	ld a, [wSpriteBrockStateData1 + SPRITESTATEDATA1_YSTEPVECTOR]
	add a ; double for 2 pixels per frame
	ld b, a
	ld a, [wSpriteBrockStateData1 + SPRITESTATEDATA1_YPIXELS]
	add b
	ld [wSpriteBrockStateData1 + SPRITESTATEDATA1_YPIXELS], a

	; Update X pixel position
	ld a, [wSpriteBrockStateData1 + SPRITESTATEDATA1_XSTEPVECTOR]
	add a ; double for 2 pixels per frame
	ld b, a
	ld a, [wSpriteBrockStateData1 + SPRITESTATEDATA1_XPIXELS]
	add b
	ld [wSpriteBrockStateData1 + SPRITESTATEDATA1_XPIXELS], a
	ret

; =====================================
; MISTY COMMAND BUFFER MANAGEMENT
; =====================================

ClearMistyFollowCommandBuffer:
; Clear command buffer - matches Pikachu's approach
	push bc
	ld hl, wMistyFollowCommandBufferSize
	ld [hl], $ff
	inc hl
	ld bc, 8  ; 8-byte buffer
	xor a
	call FillMemory
	pop bc
	ret

AppendMistyFollowCommand::
; Legacy function - kept for compatibility with pikachu_follow.asm calls
; Real-time positioning is now used instead of buffering
	ret

GetMistyFollowCommand:
; Get and consume command from buffer (LIFO - from end)
; Matches Pikachu's Func_fcc92 approach
	ld hl, wMistyFollowCommandBufferSize
	ld a, [hl]
	cp $ff
	jr z, .empty
	and a
	jr z, .empty
	dec [hl]
	ld e, a
	ld d, 0
	ld hl, wMistyFollowCommandBuffer
	add hl, de
	inc e
	ld a, $ff
.shiftLoop
	ld d, [hl]
	ld [hld], a
	ld a, d
	dec e
	jr nz, .shiftLoop
	and a  ; clear carry
	ret

.empty
	scf
	ret

; =====================================
; BROCK COMMAND BUFFER MANAGEMENT
; =====================================

ClearBrockFollowCommandBuffer:
; Clear command buffer - matches Pikachu's approach
	push bc
	ld hl, wBrockFollowCommandBufferSize
	ld [hl], $ff
	inc hl
	ld bc, 8  ; 8-byte buffer
	xor a
	call FillMemory
	pop bc
	ret

AppendBrockFollowCommand::
; Legacy function - kept for compatibility with pikachu_follow.asm calls
; Real-time positioning is now used instead of buffering
	ret

GetBrockFollowCommand:
; Get and consume command from buffer (LIFO - from end)
; Matches Pikachu's Func_fcc92 approach
	ld hl, wBrockFollowCommandBufferSize
	ld a, [hl]
	cp $ff
	jr z, .empty
	and a
	jr z, .empty
	dec [hl]
	ld e, a
	ld d, 0
	ld hl, wBrockFollowCommandBuffer
	add hl, de
	inc e
	ld a, $ff
.shiftLoop
	ld d, [hl]
	ld [hld], a
	ld a, d
	dec e
	jr nz, .shiftLoop
	and a  ; clear carry
	ret

.empty
	scf
	ret

; =====================================
; MISTY FOLLOW COMMAND COMPUTATION
; =====================================

ComputeMistyFollowCommand:
; Compute direction from Misty to Pikachu
; Misty should stay 1 tile behind Pikachu, not on top
; Returns: a = command (1-4 normal speed, 5-8 fast speed), carry set if no movement needed
	; First check distance
	call GetMistyDistanceToPikachu
	; Returns: b = Y distance (signed), c = X distance (signed), a = Manhattan distance
	cp 2
	jr c, .onTarget  ; distance 0 or 1 = close enough, don't move
	                 ; (if on top, Pikachu will move and create space)

	; More than 1 tile away - need to move closer
	; Check Y first
	ld a, b  ; Y distance
	and a
	jr z, .checkXDistance
	bit 7, a
	jr nz, .mistyBelowPikachu  ; negative = Misty below

	; Misty is above Pikachu - move down
	ld a, b
	call CheckDistanceGreaterThan1
	jr c, .downNormal
	ld a, 5  ; fast down
	and a
	ret
.downNormal
	ld a, 1  ; normal down
	and a
	ret

.mistyBelowPikachu
	; Misty is below Pikachu - move up
	ld a, b
	call CheckDistanceGreaterThan1
	jr c, .upNormal
	ld a, 6  ; fast up
	and a
	ret
.upNormal
	ld a, 2  ; normal up
	and a
	ret

.checkXDistance
	; Y is aligned, check X
	ld a, c  ; X distance
	and a
	jr z, .onTarget  ; shouldn't happen, but safety
	bit 7, a
	jr nz, .mistyRightOfPikachu  ; negative = Misty to right

	; Misty is left of Pikachu - move right
	ld a, c
	call CheckDistanceGreaterThan1
	jr c, .rightNormal
	ld a, 8  ; fast right
	and a
	ret
.rightNormal
	ld a, 4  ; normal right
	and a
	ret

.mistyRightOfPikachu
	; Misty is right of Pikachu - move left
	ld a, c
	call CheckDistanceGreaterThan1
	jr c, .leftNormal
	ld a, 7  ; fast left
	and a
	ret
.leftNormal
	ld a, 3  ; normal left
	and a
	ret

.onTopOfPikachu
	; On same tile as Pikachu - move opposite to Pikachu's facing
	ld a, [wSpritePikachuStateData1FacingDirection]
	and a  ; SPRITE_FACING_DOWN (0)
	jr z, .moveUp      ; Pikachu faces down, Misty moves up (behind)
	cp SPRITE_FACING_UP
	jr z, .moveDown    ; Pikachu faces up, Misty moves down
	cp SPRITE_FACING_LEFT
	jr z, .moveRight   ; Pikachu faces left, Misty moves right
	; SPRITE_FACING_RIGHT - Misty moves left
	ld a, 3
	and a
	ret
.moveUp
	ld a, 2
	and a
	ret
.moveDown
	ld a, 1
	and a
	ret
.moveRight
	ld a, 4
	and a
	ret

.onTarget
	; Exactly 1 tile away - perfect position, no movement
	scf
	ret

GetMistyDistanceToPikachu:
; Returns: b = Y distance (Pikachu.Y - Misty.Y, signed)
;          c = X distance (Pikachu.X - Misty.X, signed)
;          a = Manhattan distance (|b| + |c|)
	ld a, [wSpritePikachuStateData2MapY]
	ld d, a
	ld a, [wSpriteMistyStateData2MapY]
	ld e, a
	ld a, d
	sub e  ; a = Pikachu.Y - Misty.Y
	ld b, a  ; save Y distance

	ld a, [wSpritePikachuStateData2MapX]
	ld d, a
	ld a, [wSpriteMistyStateData2MapX]
	ld e, a
	ld a, d
	sub e  ; a = Pikachu.X - Misty.X
	ld c, a  ; save X distance

	; Compute Manhattan distance = |b| + |c|
	ld a, b
	call AbsoluteValue
	ld d, a
	ld a, c
	call AbsoluteValue
	add d  ; a = |Y| + |X|
	ret

AbsoluteValue:
; Returns absolute value of a
	bit 7, a
	ret z  ; already positive
	cpl
	inc a
	ret

CheckDistanceGreaterThan1:
; Check if absolute value of a is >= 2
; Returns carry if |a| < 2 (distance = 0 or 1), no carry if >= 2
	call AbsoluteValue
	cp 2
	ret

; =====================================
; MISTY FACING DIRECTION COMPUTATION
; =====================================

ComputeMistyFacingDirection:
; Compute facing direction based on Misty's position relative to Pikachu
; Does NOT consume from command buffer - just computes facing based on position
	; Compare Y coordinates
	ld a, [wSpritePikachuStateData2MapY]
	ld b, a
	ld a, [wSpriteMistyStateData2MapY]
	cp b
	jr z, .checkX
	jr c, .mistyAbovePikachu

	; Misty is below Pikachu - face up
	ld a, SPRITE_FACING_UP
	jr .setFacing

.mistyAbovePikachu
	; Misty is above Pikachu - face down
	ld a, SPRITE_FACING_DOWN
	jr .setFacing

.checkX
	; Y coords equal - check X
	ld a, [wSpritePikachuStateData2MapX]
	ld b, a
	ld a, [wSpriteMistyStateData2MapX]
	cp b
	jr z, .copyPikachuFacing
	jr c, .mistyLeftOfPikachu

	; Misty is right of Pikachu - face left
	ld a, SPRITE_FACING_LEFT
	jr .setFacing

.mistyLeftOfPikachu
	; Misty is left of Pikachu - face right
	ld a, SPRITE_FACING_RIGHT
	jr .setFacing

.copyPikachuFacing
	; On same tile - copy Pikachu's facing direction
	ld a, [wSpritePikachuStateData1FacingDirection]

.setFacing
	ld [wSpriteMistyStateData1FacingDirection], a
	ret

; =====================================
; MISTY WALKING SPRITE UPDATE
; =====================================

UpdateMistyWalkingSprite:
; Update sprite image index based on facing direction and animation frame
; Similar to UpdatePikachuWalkingSprite
	ld a, [wSpriteMistyStateData2ImageBaseOffset]
	dec a
	swap a  ; shift left by 4 bits
	and $f0  ; mask to upper 4 bits
	ld b, a
	ld a, [wSpriteMistyStateData1FacingDirection]
	or b
	ld b, a
	
	; Add animation frame counter
	ld a, [wSpriteMistyStateData1AnimFrameCounter]
	or b
	ld [wSpriteMistyStateData1ImageIndex], a
	ret

; =====================================
; BROCK FOLLOW COMMAND COMPUTATION
; =====================================

ComputeBrockFollowCommand:
; Compute direction from Brock to Misty
; Brock should stay 1 tile behind Misty, not on top
; Returns: a = command (1-4 normal speed, 5-8 fast speed), carry set if no movement needed
	; First check if we're exactly 1 tile away (on target)
	call GetBrockDistanceToMisty
	; Returns: b = Y distance (signed), c = X distance (signed), a = Manhattan distance
	cp 1
	jr z, .onTarget  ; exactly 1 tile away = perfect position
	and a
	jr z, .onTopOfMisty  ; 0 tiles = need to back off

	; More than 1 tile away - need to move closer
	; Check Y first
	ld a, b  ; Y distance
	and a
	jr z, .checkXDistance
	bit 7, a
	jr nz, .brockBelowMisty  ; negative = Brock below

	; Brock is above Misty - move down
	ld a, b
	call CheckDistanceGreaterThan1
	jr c, .downNormal
	ld a, 5  ; fast down
	and a
	ret
.downNormal
	ld a, 1  ; normal down
	and a
	ret

.brockBelowMisty
	; Brock is below Misty - move up
	ld a, b
	call CheckDistanceGreaterThan1
	jr c, .upNormal
	ld a, 6  ; fast up
	and a
	ret
.upNormal
	ld a, 2  ; normal up
	and a
	ret

.checkXDistance
	; Y is aligned, check X
	ld a, c  ; X distance
	and a
	jr z, .onTarget  ; shouldn't happen, but safety
	bit 7, a
	jr nz, .brockRightOfMisty  ; negative = Brock to right

	; Brock is left of Misty - move right
	ld a, c
	call CheckDistanceGreaterThan1
	jr c, .rightNormal
	ld a, 8  ; fast right
	and a
	ret
.rightNormal
	ld a, 4  ; normal right
	and a
	ret

.brockRightOfMisty
	; Brock is right of Misty - move left
	ld a, c
	call CheckDistanceGreaterThan1
	jr c, .leftNormal
	ld a, 7  ; fast left
	and a
	ret
.leftNormal
	ld a, 3  ; normal left
	and a
	ret

.onTopOfMisty
	; On same tile as Misty - move opposite to Misty's facing
	ld a, [wSpriteMistyStateData1FacingDirection]
	and a  ; SPRITE_FACING_DOWN (0)
	jr z, .moveUp      ; Misty faces down, Brock moves up (behind)
	cp SPRITE_FACING_UP
	jr z, .moveDown    ; Misty faces up, Brock moves down
	cp SPRITE_FACING_LEFT
	jr z, .moveRight   ; Misty faces left, Brock moves right
	; SPRITE_FACING_RIGHT - Brock moves left
	ld a, 3
	and a
	ret
.moveUp
	ld a, 2
	and a
	ret
.moveDown
	ld a, 1
	and a
	ret
.moveRight
	ld a, 4
	and a
	ret

.onTarget
	; Exactly 1 tile away - perfect position, no movement
	scf
	ret

GetBrockDistanceToMisty:
; Returns: b = Y distance (Misty.Y - Brock.Y, signed)
;          c = X distance (Misty.X - Brock.X, signed)
;          a = Manhattan distance (|b| + |c|)
	ld a, [wSpriteMistyStateData2MapY]
	ld d, a
	ld a, [wSpriteBrockStateData2MapY]
	ld e, a
	ld a, d
	sub e  ; a = Misty.Y - Brock.Y
	ld b, a  ; save Y distance

	ld a, [wSpriteMistyStateData2MapX]
	ld d, a
	ld a, [wSpriteBrockStateData2MapX]
	ld e, a
	ld a, d
	sub e  ; a = Misty.X - Brock.X
	ld c, a  ; save X distance

	; Compute Manhattan distance = |b| + |c|
	ld a, b
	call AbsoluteValue
	ld d, a
	ld a, c
	call AbsoluteValue
	add d  ; a = |Y| + |X|
	ret

; =====================================
; MISTY INITIALIZATION (called from script)
; =====================================

InitializeMistyFollower::
; Called when Misty first starts following - clears state and initializes position
	; Clear state flags (ensures spawn conditions can pass)
	xor a
	ld [wMistyOverworldStateFlags], a

	; Clear StateData1 (16 bytes) - note: StateData1 and StateData2 are NOT contiguous
	ld hl, wSpriteMistyStateData1
	ld bc, $10
	xor a
	call FillMemory

	; Clear StateData2 (16 bytes) - in separate memory page
	ld hl, wSpriteMistyStateData2
	ld bc, $10
	xor a
	call FillMemory

	; Set sprite picture ID
	ld a, SPRITE_BRUNETTE_GIRL
	ld [wSpriteMistyStateData1PictureID], a
	ld [wSpriteMistyStateData2PictureID], a

	; Set VRAM slot (ImageBaseOffset) - required for sprite to be processed
	ld a, $3  ; Misty is in VRAM slot 3 (after player=1, pikachu=2)
	ld [wSpriteMistyStateData2ImageBaseOffset], a

	; Set image index to $ff (will be updated on first spawn)
	ld a, $ff
	ld [wSpriteMistyStateData1ImageIndex], a

	; Clear movement status (will be set by InitializeMistyPosition)
	xor a
	ld [wSpriteMistyStateData1MovementStatus], a

	; Clear command buffer
	call ClearMistyFollowCommandBuffer

	; Initialize position (behind Pikachu)
	call InitializeMistyPosition

	; Set initial image index (same calculation as UpdatePikachuWalkingSprite)
	; ImageIndex = (ImageBaseOffset - 1) << 4 | FacingDirection | AnimFrameCounter
	ld a, [wSpriteMistyStateData2ImageBaseOffset]
	dec a
	swap a  ; shift left by 4 bits
	and $f0  ; mask to upper 4 bits
	ld b, a
	ld a, [wSpriteMistyStateData1FacingDirection]
	or b
	ld [wSpriteMistyStateData1ImageIndex], a

	; Clear anim frame counter
	xor a
	ld [wSpriteMistyStateData1AnimFrameCounter], a

	ret

; =====================================
; HELPER: Initialize Follower Screen Position
; (This reuses existing InitializeSpriteScreenPosition)
; =====================================

; Note: The farcall to InitializeSpriteScreenPosition requires bc to point
; to the sprite's StateData1 base address
